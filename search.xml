<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[02_变量的定义]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FES6%2F4f798200.html</url>
    <content type="text"><![CDATA[(定义)声明变量var定义变量的一些问题:12345678&lt;script type="text/javascript"&gt; for(var i = 0; i &lt; 10; i++) &#123; // TODO &#125; alert(i); // 下面使用i默认从10开始&lt;/script&gt;问题: i的结果是10。这里在之前的版本中，作用域分为：全局、函数作用域。ES6:块级作用域作用域问题12345678&lt;script type="text/javascript"&gt; function fn() &#123; alert(a); &#125; fn(); // 报错:Uncaught ReferenceError: a is not defined // 这是正常情况&lt;/script&gt;123456789&lt;script type="text/javascript"&gt; var a = 12; function fn() &#123; alert(a); &#125; fn(); // 弹出12 // 正常情况&lt;/script&gt;12345678910111213141516171819&lt;script type="text/javascript"&gt; var a = 12; function fn() &#123; alert(a); var a = 5; // 这是因为变量提升（预解析）,也是js的特性 &#125; fn(); // 弹出undefined // 类似于下面代码(当前这种情况是不好的，我们在ES6中不希望出现这种特性) // var a; function fn() &#123; var a; alert(a); // var a = 5; a = 5; &#125;&lt;/script&gt;let和constlet: 类似与之前的varconst: 常量，定义好了不能改变使用如下:1234567&lt;script type="text/javascript"&gt; let a = 12; function fn() &#123; console.log(a); // 打印：12 &#125;&lt;/script&gt;let和const定义的变量具备块级作用域(只要带有花括号都有)，如下：12345678910111213&lt;script type="text/javascript"&gt; if(true) &#123; var a = 12; &#125; alert(a); // 可以弹出12,能正常使用 if(true) &#123; let b = 12; &#125; alert(b); // 报错:Uncaught ReferenceError: b is not defined&lt;/script&gt;没有预解析，不存在变量提升12345678910&lt;script type="text/javascript"&gt; let a = 12; function fn() &#123; alert(a); // TDZ 开始 暂时性死区 let a = 5; // TDZ 结束 // 代码块中有a则一定用的是代码块的a &#125; // 报错:Uncaught ReferenceError: a is not defined // 因为fn函数内有a,但是alert的时候，a还没有定义。把let a = 5放在alert(a)；上面一行即可。&lt;/script&gt;let不能被重复定义变量1234567&lt;script type="text/javascript"&gt; var a = 12; // TODO var a = 5; alert(a); // 弹出5，a被覆盖&lt;/script&gt;1234567&lt;script type="text/javascript"&gt; let a = 12; // TODO let a = 5; alert(a); // 报错:Uncaught ReferenceError: Identifier 'a' has already been declared&lt;/script&gt;for循环,for循环里面是父级作用域12345678&lt;script type="text/javascript"&gt; for(let i = 0; i &lt; 3; i++) &#123; // TODO // 本区域可用 &#125; alert(i); // 报错:Uncaught ReferenceError: a is not defined&lt;/script&gt;具备块级作用域1234567&lt;script type="text/javascript"&gt; for(let i = 0; i &lt; 3; i++) &#123; // TODO console.log(i); &#125; // 循环打印三行1,2,3&lt;/script&gt;123456789&lt;script type="text/javascript"&gt; for(let i = 0; i &lt; 3; i++) &#123; // TODO // let i = 'abc'; console.log(i); &#125; // 打印三次'abc' // 不是重复定义，for循环里面是父级作用域，内部重新定义则使用子级作用域&lt;/script&gt;12345678910&lt;script type="text/javascript"&gt; let a = 12; &#123; let a = 5; console(a); &#125; console(a); // 打印5 // 打印12&lt;/script&gt;相比var，let更符合程序运行流程1234567891011&lt;script type="text/javascript"&gt; var arr = []; for(var i = 0; i &lt; 10; i++) &#123; arr[i] = function() &#123; console.log(i); &#125; &#125; arr[5](); // 输出结果10，原因i是全局变量。&lt;/script&gt;1234567891011&lt;script type="text/javascript"&gt; let arr = []; for(let i = 0; i &lt; 10; i++) &#123; arr[i] = function() &#123; console.log(i); &#125; &#125; arr[5](); // 输出结果5，原因i是全局变量。&lt;/script&gt;获取选项卡案例12345678910111213141516171819202122232425262728 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href=""&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="aaa" /&gt; &lt;input type="button" value="bbb" /&gt; &lt;input type="button" value="ccc" /&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var aInput = document.querySelectorAll('input'); for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function() &#123; alert(i); &#125; &#125; &#125; // 点击哪个按钮弹出都是3，当把var换成let就彻底符合流程了 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;let总结注意：1.没有预解析，不存在变量提升。在代码块内，只要let定义变量，在之前使用都会报错。必须先定义，在使用。2.同一个作用域里，不能重复定义变量。3.for循环,for循环里面是父级作用域，里面有一个const特性和let一样，const定义变量不能修改。定义变量不能修改在某些开发中，如配置文件，一些定死不需要修改的变量，即常量12345&lt;script type="text/javascript"&gt; let http = require('http'); http = "a"; console.log(http);&lt;/script&gt;123456&lt;script type="text/javascript"&gt; const http = require('http'); http = "a"; console.log(http); // 报错:Uncaught TypeError: Assignment to constant variable.&lt;/script&gt;const定义完变量，必须有值，不能后赋值，不能修改123456789&lt;script type="text/javascript"&gt; const a = 123; function show() &#123; console.log(a); // TDZ 暂时性死区 const a = 5; &#125; show(); // 报错:Uncaught ReferenceError: Cannot access 'a' before initialization&lt;/script&gt;123456&lt;script type="text/javascript"&gt; const arr = ['apple', 'banana']; arr = []; console.log(arr); // 结果:Uncaught TypeError: Assignment to constant variable.&lt;/script&gt;1234567&lt;script type="text/javascript"&gt; const arr = ['apple', 'banana']; arr.push('orange'); console.log(arr); // 对象本身是引用的,如果需要冻结对象本身，则需要使用Object.freeze(对象) // 输出：(3) ["apple", "banana", "orange"]&lt;/script&gt;Object.freeze(对象)1234567&lt;script type="text/javascript"&gt; const arr = Object.freeze(['apple', 'banana']); arr.push('orange'); console.log(arr); // Uncaught TypeError: Cannot add property 2, object is not extensible // at Array.push (&lt;anonymous&gt;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_ECMA介绍]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FES6%2F4ba0bd93.html</url>
    <content type="text"><![CDATA[ECMA背景ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。ECMAScript 规范定义了一种脚本语言实现应该包含的内容，但是，因为它是可扩充的，所以其实现所提供的功能与这个最小集相比可能变化很大。 ECMAScript本身并不是一种脚本语言。正如在 Web 应用程序中执行有用操作的 bean 集合（例如，Netscape 的 AWT）是 Sun 的 JavaBean 规范的一种实现一样，JavaScript 是 ECMAScript 规范的一种实现。一分钟了解ECMAScript的发展历程1996 年 11月JavaScript 的创造者 Netscape 公司将 JavaScript 提交给标准化组织 ECMA（European Computer Manufacturers Association）。1997年 ES1ECMA 发布 262 号标准文件（ECMA-262），规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript (ES).1998年 ES2内容编辑加工，没有特性修改。1999年 ES3有较完善的修改，成为JavaScript的通行标准，得到了广泛支持。2000年 ES4 , 2008年终止也称作JavaScript 2，因改动太大没有通过，Harmony项目启动来跟进，ES4大部分内容被 ES6 继承. Harmony部分内容放到ES6之后。2009年 ES5(ES3.1)新功能主要包括：JSON对象（包含parse/stringify等方法）、Array和Object增加一些方法，严格模式（use strict），函数的bind方法。2011年 ES5.1成为 ISO 国际标准（ISO/IEC 16262:2011)， 到了2012年底，主流浏览器都支持ECMAScript 5.1的全部功能2015年 ES2015(ES6)做了大量的更新，但向后兼容。ES6是一次重大改进。部分功能：let/const、变量的解构赋值、Promise、箭头函数…2016年 ES2016(ES7)新功能主要包括：1.Array.prototype.includes检查数组中是否存在值；（区别ES6字符串的includes方法）2.Exponentiation Operator 求幂运算 (a ** b等价于Math.pow(a,b))规范地址：http://www.ecma-international.org/ecma-262/7.0/2017年 ES2017(ES8)部分功能：1.Object.values/entries/getOwnPropertyDescriptors2.String.prototype.padStart/padEnd3.函数参数列表和调用中的尾逗号（Trailing commas）4.Async Functions 异步函数（async/await）规范地址：http://www.ecma-international.org/ecma-262/8.0/JavaScript标准的发展历程ECMAScript：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。JavaScript：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。ECMAScript 2016：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定ECMAScript Proposals：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。JavaScript的版本历程1997年7月，ECMAScript 1.0发布。1998年6月，ECMAScript 2.0版发布。1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39的总体考虑是，ECMAScript 5与ECMAScript 3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ECMAScript 6。第六版发布以后，将指ECMAScript 7。TC39预计，ECMAScript 5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1版的全部功能。2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。2015年6月，ECMAScript 6正式发布，并且更名为“ECMAScript 2015”。这是因为TC39委员会计划，以后每年发布一个ECMAScirpt的版本，下一个版本在2016年发布，称为“ECMAScript 2016”。除了ECMAScript的版本，很长一段时间中，Netscape公司（以及继承它的Mozilla基金会）在内部依然使用自己的版本号。这导致了JavaScript有自己不同于ECMAScript的版本号。1996年3月，Navigator 2.0内置了JavaScript 1.0。JavaScript 1.1版对应ECMAScript 1.0，但是直到JavaScript 1.4版才完全兼容ECMAScript 1.0。JavaScript 1.5版完全兼容ECMAScript 3.0。目前的JavaScript 1.8版完全兼容ECMAScript 5。ES语法提案的五个阶段：Stage 0 - Strawman（展示阶段）Stage 1 - Proposal（征求意见阶段）Stage 2 - Draft（草案阶段）Stage 3 - Candidate（候选人阶段）Stage 4 - Finished（定案阶段）提案地址:https://github.com/tc39/ecma262ES6环境Chrome对新的语法支持很迅速，可以直接写js通过Chrom浏览器解析执行转码器:webpack3.x Traceures6不像es5那么简单，它需要有es5的前置知识，要懂得es5的基本语法，跟es5不同的是，es6需要搭建环境，不像es5那样直接就可以编写运行，因为有些浏览器还是不支持es6的，所以还需要babel对其进行转换，接下来就开始环境的搭建吧。首先选择一个盘新建目录文件，我新建的是es6文件夹，在该文件夹新建一个src文件，用来存放js文件，新建一个dist文件，用来存放转换为es5语法的js文件，还有建立一个index.html文件，src下新建一个index.js文件，在index.html中加入&lt;script src=”./dist”&gt;&lt;/script&gt;如下所示：然后对项目进行初始化，在控制台切换到该目录下，输入”npm init -y”即生成一个package.json文件，打开文件内容，下面是对里面内容的讲解：然后开始环境的搭建：先输入”npm install babel-cli -g”对bebal进行全局安装，如果网速较慢，可以使用cnpm接着再输入”npm install –save-dev babel-preset-es2015 babel-cli“，将babel-preset-es2015和babel-cli进行本地安装，安装成功后就会在package.json文件中有记录，如图：接着新建一个.babelrc文件，在文件中输入：这时在控制台输入”babel src/index.js -o dist/index.js”，-o表示输出，即将src下的文件index.js通过babel转换器转换后输出到dist文件夹下的index.js文件。以下是本次的测试：src下的index.jsdist下的index.js为了可以简化输入语句，可以通过在package.json文件中的scripts属性进行更改：这时只需要在控制台输入”npm run build”即可达到在控制台输入babel src/index.js -o dist/index.js相同的效果。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 SpringCloud服务注册与发现]]></title>
    <url>%2FSpring-Cloud%2Fdeef0f2a.html</url>
    <content type="text"><![CDATA[什么是服务治理在传统rpc远程调用中，服务与服务依赖关系，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。服务注册与发现在服务注册与发现中，有一个注册中心，当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，让后在实现rpc调用。搭建注册中心常用注册中心框架1) 服务注册与发现原理 在任何rpc远程框架中，都会有一个注册中心2) 注册中心概念: 存放服务地址相关信息(接口地址)SpringCloud中支持以下三种注册中心Eurcka、Consul(go语言编写)、ZookeeperDubbo支持常用两种Redis和Zookeeper服务提供者: 提供服务接口意思服务消费者: 调用别人接口进行使用一个服务既可以作为提供者，也可以作为消费者。注:eureka 英[juˈri:kə] 美[jʊ’ri:kə]注册中心环境搭建Maven依赖信息1234567891011121314151617181920212223242526272829303132333435&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- 管理依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!--SpringCloud eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;application.yml123456789101112131415###服务端口号server: port: 8100###eureka 基本信息配置eureka: instance: ###注册到eurekaip地址 hostname: 127.0.0.1 client: serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ ###因为自己是为注册中心，不需要自己注册自己 register-with-eureka: false ###因为自己是为注册中心，不需要检索服务 fetch-registry: false启动Eureka服务@EnableEurekaServer作用:开启eurekaServer123456789@EnableEurekaServer@SpringBootApplicationpublic class AppEureka &#123; public static void main(String[] args) &#123; SpringApplication.run(AppEureka.class, args); &#125;&#125;注册服务提供者项目案例：实现会员服务（提供者）springcloud-2.0-member调用订单服务(消费者)springcloud-2.0-orderMaven依赖信息12345678910111213141516171819202122232425262728293031323334353637383940&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- 管理依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;application.yml123456789101112131415161718###服务启动端口号server: port: 8000###服务名称(服务注册到eureka名称) spring: application: name: app-itmayiedu-member###服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:8100/eureka ###因为该应用为注册中心，不会注册自己 register-with-eureka: true ###是否需要从eureka上获取注册信息 fetch-registry: true服务接口12345678@RestControllerpublic class MemberController &#123; @RequestMapping("/getMember") public String getMember() &#123; return "this is getMember"; &#125;&#125;启动会员服务123456789@SpringBootApplication@EnableEurekaClientpublic class AppMember &#123; public static void main(String[] args) &#123; SpringApplication.run(AppMember.class, args); &#125;&#125;服务消费者Maven依赖信息1234567891011121314151617181920212223242526272829303132333435363738394041&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- 管理依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;Application.yml配置123456789101112131415161718###服务启动端口号server: port: 8001###服务名称(服务注册到eureka名称) spring: application: name: app-itmayiedu-order###服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:8100/eureka ###因为该应用为注册中心，不会注册自己 register-with-eureka: true ###是否需要从eureka上获取注册信息 fetch-registry: true使用rest方式调用服务123456789101112131415@RestControllerpublic class OrderController &#123; @Autowired private RestTemplate restTemplate; @RequestMapping("/getorder") public String getOrder() &#123; // order 使用rpc 远程调用技术 调用 会员服务 String memberUrl = "http://app-itmayiedu-member/getMember"; String result = restTemplate.getForObject(memberUrl, String.class); System.out.println("订单服务调用会员服务,result:" + result); return result; &#125;&#125;启动消费者服务123456789101112131415@SpringBootApplication@EnableEurekaClientpublic class AppOrder &#123; public static void main(String[] args) &#123; SpringApplication.run(AppOrder.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125;@LoadBalanced就能让这个RestTemplate在请求时拥有客户端负载均衡的能力高可用注册中心在微服务中，注册中心非常核心，可以实现服务治理，如果一旦注册出现故障的时候，可能会导致整个微服务无法访问，在这时候就需要对注册中心实现高可用集群模式。Eureka高可用原理默认情况下Eureka是让服务注册中心，不注册自己1234### 因为该应用为注册中心，不会注册自己register-with-eureka: true### 不需要去注册中心上检索服务fetch-registry: trueEureka高可用实际上将自己作为服务向其他服务注册中心注册自己，这样就可以形成一组相互注册的服务注册中心，从而实现服务清单的互相同步，达到高可用效果。Eureka集群环境搭建Eureka01配置123456789101112131415161718###服务端口号server: port: 8100###eureka 基本信息配置spring: application: name: eureka-servereureka: instance: ###注册到eurekaip地址 hostname: 127.0.0.1 client: serviceUrl: defaultZone: http://127.0.0.1:8200/eureka/ ###因为自己是为注册中心，不需要自己注册自己 register-with-eureka: true ###因为自己是为注册中心，不需要检索服务 fetch-registry: trueEureka02配置123456789101112131415161718###服务端口号server: port: 8200###eureka 基本信息配置spring: application: name: eureka-servereureka: instance: ###注册到eurekaip地址 hostname: 127.0.0.1 client: serviceUrl: defaultZone: http://127.0.0.1:8100/eureka/ ### 因为自己是为注册中心，不需要自己注册自己 register-with-eureka: true ### 因为自己是为注册中心，不需要检索服务 fetch-registry: true客户端集成Eureka集群12345678910111213141516server: port: 8000spring: application: name: app-itmayiedu-member#eureka:# client:# service-url:# defaultZone: http://localhost:8100/eureka###集群地址eureka: client: service-url: defaultZone: http://localhost:8100/eureka,http://localhost:8200/eureka register-with-eureka: true fetch-registry: trueMaven配置1234567891011121314151617181920212223242526272829303132333435&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- 管理依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!--SpringCloud eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;课程截图rpc核心服务注册与发现原理注册中心原理负载均衡]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 网站架构演变过程]]></title>
    <url>%2FSpring-Cloud%2Faba82773.html</url>
    <content type="text"><![CDATA[传统项目架构(单点应用，SSH或者SSM架构)传统的SSH架构，分为三层架构 web控制层、业务逻辑层、数据库访问层。传统架构也就是单点应用，就是大家在刚开始初学JavaEE技术的时候SSH架构或者SSM架构，业务没有进行拆分，都写同一个项目工程里面，一般是适合于个人或者是小团队开发。这种架构模式，一旦有一个模块导致服务不可用，可能会影响整个项目。什么是项目集群多台服务器部署相同应用构成一个集群作用：通过负载均衡设备共同对外提供服务分布式项目架构分布式架构基于传统架构演变过来，将传统的单体项目以项目模块进行拆分，拆分为会员项目、订单项目、支付项目、优惠券项目等，从而降低耦合度，这种项目架构模式慢慢开始适合于互联网公司规模人数开发。SOA架构SOA架构代表面向与服务架构，俗称服务化，通俗的理解为面向与业务逻辑层开发，将共同的业务逻辑抽取出来形成一个服务，提供给其他服务接口进行调用，服务与服务之间调用使用rpc远程技术。SOA架构特点:SOA架构中通常使用XML方式实现通讯，在高并发情况下XML比较冗余会带来极大的影响，所以最后微服务架构中采用JSON替代xml方式。SOA架构的底层实现通过WebService和ESB（xml与中间件混合物），Web Service技术是SOA服务化的一种实现方式，WebService底层采用soap协议进行通讯，soap协议就是Http或者是Https通道传输XML数据实现的协议。微服务架构微服务架构产生的原因微服务架构基于SOA架构演变过来的在传统的WebService架构中有如下问题:依赖中心化服务发现机制使用Soap通讯协议，通常使用XML格式来序列化通讯数据，xml格式非常喜欢重，比较占宽带传输。服务化管理和治理设施不完善漫谈微服务架构什么是微服务微服务架是从SOA架构演变过来，比SOA架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，互不影响，微服务架构更加体现轻巧、轻量级，是适合于互联网公司敏捷开发。微服务架构特征微服务架构倡导应用程序设计程多个独立、可配置、可运行和可微服务的子服务。服务与服务通讯协议采用Http协议，使用restful风格API形式来进行通讯，数据交换格式轻量级json格式通讯，整个传输过程中，采用二进制，所以http协议可以跨语言平台，并且可以和其他不同的语言进行相互的通讯，所以很多开放平台都采用http协议接口。微服务架构如何拆分微服务把每一个职责单一功能存放在独立的服务中每个服务运行在单独的进程中每个服务有自己独立数据库存储、实际上有自己独立的缓存、数据库、消息队列等资源。微服务架构与SOA架构区别微服务架构基于SOA架构演变过来，继承SOA架构的优点，在微服务架构中去除SOA架构中的ESB 消息总线，采用 http+json（restful）进行传输。微服务架构比 SOA 架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，微服务架构更加轻巧，轻量级。SOA 架构中可能数据库存储会发生共享，微服务强调独每个服务都是单独数据库，保证每个服务于服务之间互不影响。项目体现特征微服务架构比 SOA 架构更加适合与互联网公司敏捷开发、快速迭代版本，因为粒度非常精细。为什么选择SpringCloud因为SpringCloud出现,对微服务技术提供了非常大的帮助，因为SpringCloud 提供了一套完整的微服务解决方案，不像其他框架只是解决了微服务中某个问题。服务治理: 阿里巴巴开源的Dubbo和当当网在其基础上扩展的Dubbox、Eureka、Apache 的Consul等分布式配置中心: 百度的disconf、Netfix的Archaius、360的QConf、SpringCloud、携程的阿波罗等。分布式任务:xxl-job、elastic-job、springcloud的task等。服务跟踪:京东的hyra、springcloud的sleuth等。SpringCloud简介SpringCloud是基于SpringBoot基础之上开发的微服务框架，SpringCloud是一套目前非常完整的微服务解决方案框架，其内容包含服务治理、注册中心、配置管理、断路器、智能路由、微代理、控制总线、全局锁、分布式会话等。SpringCloud包含众多的子项目SpringCloud config 分布式配置中心SpringCloud netflix 核心组件Eureka:服务治理 注册中心Hystrix:服务保护框架Ribbon:客户端负载均衡器Feign：基于ribbon和hystrix的声明式服务调用组件Zuul: 网关组件,提供智能路由、访问过滤等功能。课程截图网站架构演变过程SOASOA架构网站架构演变过程之分布式架构微服务架构产生的原因为什么要使用SpringCloud官方文档SpringCloud国内翻译文档: https://springcloud.cc/spring-cloud-dalston.html]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frp实现内网穿透]]></title>
    <url>%2F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F62d5dc2c.html</url>
    <content type="text"><![CDATA[内网穿透工具frp简易教程如果你想把家里的电脑当做服务器用，做一个网站或者游戏服务器什么的，肯定会遇到一个问题：由于没有公网IP，而且有家里的路由器把关，导致其他地方的人完全无法连接到服务器。这时候就需要内网穿透和端口映射工具了，这样的工具有很多，我列举常用的几个：1) 花生壳2) nat1233) ngrok不过这几个工具虽然都算是挺好用的，但是都是收费的，虽然都有免费版，但是免费版功能实在太少，基本上只能绑定一个应用，端口号还是随机的。临时玩玩倒是可以，真正要用的话还是不行。经过一番寻找，最后我锁定了frp这个工具，它的优点就是完全开源免费，自定义配置；缺点是不提供服务，也就是说我们需要自己买个服务器在上面搭建。下载frp也是托管在Github上的开源项目，直接到Release页面下载即可，链接如下：https://github.com/fatedier/frp/releases国内提供的二进制下载网站:https://diannaobos.com/frp/下载命令:1wget http://diannaobos.iok.la:81/frp/frp-v0.20.0/frp_0.20.0_freebsd_amd64.tar.gzFrp文件目录Frp文件目录如下图所示:下载解压之后是一个文件夹，里面包含了frpc、frps可执行程序，以及它们对应的示例配置文件，前者是客户端程序，后者是服务端程序。运行frp需要同时运行客户端和服务端程序才行。full和min分别是最大和最小配置文件，如果需要参考的话可以打开看看，最大配置文件中列出了frp支持的所有选项。注:Linux版本和Windows版本基本一致(windows下执行程序为frpc.exe,Linux下位frpc)。服务器端配置(frps.ini)12345[common]bind_port = 7000token = caifenglin# vhost_http_port 网站访问端口vhost_http_port = 8080bind_port是服务端与客户端之间通信使用的端口号，默认就可以。token用于验证连接，只有服务端和客户端token相同的时候才能正常访问。如果不使用token，那么所有人都可以直接连接上，所以我建议大家在使用的时候还是把token加上。配置完毕后就可以启动服务器了,启动命令:1frps -c frps.ini客户端配置(frpc.ini)1234567891011121314[common]server_addr = 118.25.3.241server_port = 7000token = caifenglin[web]# 访问协议，如果需要https的话，只要把vhost_http_port改成vhost_https_port，再把客户端web下type设置为https即可。type = http# 本地机器IPlocal_ip = 127.0.0.1# 本地机器端口local_port = 10000# custom_domains是通过frp服务器端访问客户端的域名，必须输入完整的域名，# 并且不能是subdomain_host的子域名，否则frp服务不能启动，并且相应的域名需要解析到frp服务器端的公网IP并等待解析生效后，才可以使用。custom_domains = springbook.cnwindows启动命令:1D:\Frp\frp_0.20.0_windows_amd64&gt;frpc.exe -c frpc.ini至此，我们成功通过http//springbook.cn:8080，访问http://127.0.0.1:10000我本地局域网内的一个测试项目。仪表盘frp还支持仪表盘功能，可以从网页查看运行的流量等信息。开启仪表盘需要在服务端进行设置。123456# frps.ini[common]dashboard_port = 7500# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin设置完毕后，在浏览器中访问服务端地址:端口号并输入用户名与密码即可查看仪表盘。以上就是frp的一些介绍，如果有需要的请查看官方中文文档，详细列出了frp支持的各项功能，还可以参考frpc_full.ini与frps_full.ini，查看完整配置文件支持的选项。文档地址:https://github.com/fatedier/frp/blob/master/README_zh.md。]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 Jedis操作Redis]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2Fd5d71bc6.html</url>
    <content type="text"><![CDATA[Jedis操作Redis下载Jedis和Commons-Pool下载Jedis浏览器打开:http://search.maven.org/,搜索jedis，在Download处，点击jar下载Commons-PoolJedis对象并不是线程安全的，在多线程下使用同一个Jedis对象会出现并发问题。为了避免每次使用Jedis对象时都需要重新构建，Jedis提供了JedisPool。JedisPool是基于Commons Pool2实现的一个线程安全的连接池。浏览器打开:http://search.maven.org/,搜索commons-pool2，在Download处，点击jarJava应用使用Jedis准备项目中加入jar:jedis-3.0.1.jarcommons-pool2-2.6.1.jarslf4j-api-1.7.26.jar(commons-pool2-2.6.1.jar依赖日志组件)加入后如下图:字符串(string)1234567891011121314151617181920212223242526272829package club.smartdot.string;import java.util.List;import redis.clients.jedis.Jedis;public class RedisString &#123; public static void main(String[] args) &#123; // 创建Jedis对象,连接到Redis,需要提供ip和port Jedis jedis = new Jedis("127.0.0.1", 6379); // 添加字符串 jedis.set("breakfast", "豆浆和包子"); String mybreak = jedis.get("breakfast"); System.out.println("我的早餐1:" + mybreak); // 追加内容 jedis.append("breakfast", "还有鸡蛋"); mybreak = jedis.get("breakfast"); System.out.println("我的早餐2:" + mybreak); // 一次设置多个key-value jedis.mset("lunch", "红烧肉", "dinner", "牛肉面"); // 获取多个key的value List&lt;String&gt; dinners = jedis.mget("lunch", "dinner"); for (String dinner : dinners) &#123; System.out.println("我吃的是" + dinner); &#125; &#125;&#125;哈希(hash)1) 使用Jedis连接实例池12345678910111213141516171819202122232425262728293031323334353637package club.smartdot.util;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class RedisUtil &#123; // 定义连接池对象 private static JedisPool pool = null; // 创建连接池 public static JedisPool open(String host, int port) &#123; if(pool == null) &#123; // 使用JedisPool JedisPoolConfig config = new JedisPoolConfig(); // 最大的Jedis实例数(连接池中是Jedis实例，默认是8) config.setMaxTotal(10); // 最大的空闲实例数,设置这个可以保留足够的连接，快速的获取到Jedis对象 config.setMaxIdle(3); // 提前检查Jedis对象,为true获取的Jedis一定是可用的 config.setTestOnBorrow(true); // 创建Jedis连接池，Redis没有访问密码时的使用方式 // pool = new JedisPool(config, host, port); /** * 创建Jedis连接池，Redis有访问密码时的使用方式 * 参数: JedisPoolCOnfig Redis的主机地址 端口 连接超时时间单位毫秒 访问密码 */ pool = new JedisPool(config, host, port, 60*1000, "caifenglin"); &#125; return pool; &#125; // 关闭连接池 public static void close() &#123; if(pool != null) &#123; pool.close(); &#125; &#125;&#125;2) 使用连接池操作hash数据类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package club.smartdot.hash;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import club.smartdot.util.RedisUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class RedisHash &#123; public static void main(String[] args) &#123; // 创建连接池 JedisPool pool = RedisUtil.open("127.0.0.1", 6379); Jedis jedis = null; try &#123; // 从连接池中获取Jedis对象 jedis = pool.getResource(); // 设置hash类型。key:loginuser, filed：username，value: zhangsan jedis.hset("loginuser", "username", "zhangsan"); System.out.println("username的值:" + jedis.hget("loginuser", "username")); // 设置多个值 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("username", "caifenglin"); map.put("age", "26"); map.put("website", "www.smartdot.club"); jedis.hmset("logininfo", map); // 从Redis取hash数据 List&lt;String&gt; fieldValues = jedis.hmget("logininfo", "username", "website"); for (String fv : fieldValues) &#123; System.out.println("filed值:" + fv); &#125; // 存在username吗? System.out.println("返回boolean,存在username:" + jedis.hexists("logininfo", "username")); // 查看所有的field Set&lt;String&gt; set = jedis.hkeys("logininfo"); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext()) &#123; System.out.println("field name:" + iterator.next()); &#125; // 删除field:age jedis.hdel("logininfo", "age"); // 获取age System.out.println("age是null:" + jedis.hget("logininfo", "age")); // 所有field的数量 System.out.println("field个数:" + jedis.hlen("logininfo")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(jedis != null) &#123; // 使用完的连接池对象，放回连接池 jedis.close(); &#125; &#125; &#125;&#125;运行结果123456789101112SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.username的值:zhangsanfiled值:caifenglinfiled值:www.smartdot.club返回boolean,存在username:truefield name:websitefield name:agefield name:usernameage是null:nullfield个数:2列表list1234567891011121314151617181920212223242526272829303132333435363738394041424344package club.smartdot.list;import java.util.List;import club.smartdot.util.RedisUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.ListPosition;public class RedisList &#123; public static void main(String[] args) &#123; JedisPool pool = RedisUtil.open("127.0.0.1", 6379); Jedis jedis = null; try &#123; // 从连接池中获取Jedis对象 jedis = pool.getResource(); String key = "framework"; jedis.del(key); jedis.lpush(key, "mybatis"); jedis.lpush(key, "hibernate", "spring", "springmvc"); List&lt;String&gt; lists = jedis.lrange(key, 0, -1); for (String str : lists) &#123; System.out.println("列表数据:" + str); &#125; System.out.println("列表长度:" + jedis.llen(key)); System.out.println("插入新值后列表的长度:" + jedis.linsert(key, ListPosition.AFTER, "spring", "jpa")); // 列表右侧插入数据 jedis.rpush(key, "struts", "webwork"); System.out.println("列表数据:" + jedis.lrange(key, 0, -1)); System.out.println("第一个下标的值:" + jedis.lindex(key, 1)); for(long i = 0, len = jedis.llen(key); i &lt; len; i++) &#123; System.out.println("弹出值:" + jedis.lpop(key)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; // 使用完的连接池对象，放回连接池 jedis.close(); &#125; &#125; &#125;&#125;集合set12345678910111213141516171819202122232425262728293031323334353637383940package club.smartdot.set;import java.util.Iterator;import java.util.Set;import club.smartdot.util.RedisUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class RedisSet &#123; public static void main(String[] args) &#123; JedisPool pool = RedisUtil.open("127.0.0.1", 6379); Jedis jedis = null; try &#123; // 从连接池中获取Jedis对象 jedis = pool.getResource(); String key = "course"; // 添加一个数据 jedis.sadd(key, "html"); // 添加多个数据 jedis.sadd(key, "css", "javascript", "jquery"); Set&lt;String&gt; smembers = jedis.smembers(key); Iterator&lt;String&gt; iter = smembers.iterator(); while(iter.hasNext()) &#123; System.out.println("集合成员:" + iter.next()); &#125; // 判断spring是否在集合中 System.out.println("spring有吗?" + jedis.sismember(key, "spring")); // 集合的成员数量 System.out.println("集合成员个数:" + jedis.scard(key)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; // 使用完的连接池对象，放回连接池 jedis.close(); &#125; &#125; &#125;&#125;有序集合sorted set123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package club.smartdot.sort;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;import club.smartdot.util.RedisUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.Tuple;public class RedisSortSet &#123; public static void main(String[] args) &#123; JedisPool pool = RedisUtil.open("127.0.0.1", 6379); Jedis jedis = null; try &#123; // 从连接池中获取Jedis对象 jedis = pool.getResource(); String key = "salary"; jedis.zadd(key, 2000D, "John"); // 使用方法:zadd(String key, Map&lt;String, Double&gt;)添加多个数据 Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put("Tom", 3500D); map.put("Marry", 6500D); map.put("Rose", 3600D); map.put("Mike", 5060D); // 添加多个数据 jedis.zadd(key, map); // 查询返回全部的数据，没有score Set&lt;String&gt; zrangeByScore3 = jedis.zrangeByScore(key, "-inf", "+inf"); Set&lt;String&gt; zrangeByScore2 = zrangeByScore3; Set&lt;String&gt; zrangeByScore = zrangeByScore2; Set&lt;String&gt; sets = zrangeByScore; Iterator&lt;String&gt; iterator = sets.iterator(); while(iterator.hasNext()) &#123; System.out.println("排序小-大的成员" + iterator.next()); &#125; // 带有score的数据 Set&lt;Tuple&gt; tuple = jedis.zrangeByScoreWithScores(key, "-inf", "+inf"); Iterator&lt;Tuple&gt; iters = tuple.iterator(); while(iters.hasNext()) &#123; Tuple tu = iters.next(); System.out.println("排序小-大的成员:" + tu.getElement() + "# score:" + tu.getScore()); &#125; System.out.println("有序集合成员数据量:" + jedis.zcard(key)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; // 使用完的连接池对象，放回连接池 jedis.close(); &#125; &#125; &#125;&#125;事物(Transaction)12345678910111213141516171819202122232425262728293031323334353637package club.smartdot.transcation;import java.util.List;import club.smartdot.util.RedisUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.Transaction;public class RedisTransaction &#123; public static void main(String[] args) &#123; // 创建Jedis对象，连接到Redis, 需要提供ip和port JedisPool pool = RedisUtil.open("127.0.0.1", 6379); Jedis jedis = null; try &#123; jedis = pool.getResource(); //开启事物 Transaction transaction = jedis.multi(); // 添加字符串 transaction.mset("breakfaset", "豆浆和包子"); // 一次设置多个key-value transaction.mset("lunch", "红烧肉", "dinner", "牛肉面"); List&lt;Object&gt; results = transaction.exec(); // 事物的处理结果 for (Object result : results) &#123; System.out.println("成功的事物操作: " + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Nginx应用]]></title>
    <url>%2FNginx%2F76300df3.html</url>
    <content type="text"><![CDATA[Nginx配置段详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# 全局区#user nobody;# 有1个工作的子进程，可以自行修改，但太大无益，因为要争夺CPU# 一般设置为CPU 数*核数worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; # 一般是配置Nginx连接的特性，如1个worker能同时允许多少连接 # 这是指一个子进程最大允许连接1024个连接。 worker_connections 1024;&#125;# 这是配置http服务器的主要部分http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; # 这是配置虚拟主机部分 server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;Nginx配置虚拟主机例1:基于域名的虚拟主机123456789server &#123; listen 80; # 监听端口 server_name somename alias another.alias; # 监听域名，如有多个，空格隔开 location / &#123; root /var/www/website; # 根目录定位 index index.html index.htm; # 默认索引页 &#125;&#125;例2:Apache的虚拟主机配置1234&lt;VirtualHost 192.168.137.201:80&gt; DocumentRoot "/var/www/website" ServerName www.website.com&lt;/VirtualHost&gt;例3: 基于端口的虚拟主机配置123456789server &#123; listen 8080; # 监听端口 server_name springbook.cn; location / &#123; root /var/www/website; # 根目录定位 index index.html index.htm; # 默认索引页 &#125;&#125;日志管理我们观察Nginx的server段可以看到如下类似信息access_log logs/access.log main;这说明该server，它的访问日志的文件是logs/host、access.log,日志格式”main”格式main格式是什么12345#log_format main '$remote_addr - $remote_user [$time_local] "$request" '# '$status $body_bytes_sent "$http_referer" '# '"$http_user_agent" "$http_x_forwarded_for"';#access_log logs/access.log main;除了main格式，你可以自定义其它格式123log_format mylog '$remote_addr [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent"';12345678server &#123; listen 80; # 下面声明a.com使用mylog格式日志，并保存在logs/a.com.log文件中 access_log logs/a.com.log mylog; server_name springbook.cn; ···&#125;main格式是我们定义好一种日志的格式，并起个名字，便于引用。以上面的例子，main类型的日志记录的remote_addr···http_x_forwarded_for等选项。日志格式:是指记录哪些选项默认的日志格式: main123#log_format main '$remote_addr - $remote_user [$time_local] "$request" '# '$status $body_bytes_sent "$http_referer" '# '"$http_user_agent" "$http_x_forwarded_for"';如默认的main日志格式,记录这么几项远程IP 远程用户 用户时间 请求方法(如GET/POST) 请求体长度 referer来源信息 http-user-agent 用户代理/蜘蛛，被转发的请求的原始IP http_x_forwarded_for在经过代理时，代理把你的本来IP加在此头信息中，传输你的原始IP。实际应用: Shell+定时任务+Nginx信号管理，完成日志按日期存储。PHP配置移植略pathinfo支持pathinfo类似于java开发中的restful风格12345678910111213141516171819典型配置location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_params;&#125;# 修改1,5,6行，支持pathinfolocation ~ \.php(.*) &#123; # 正则匹配，php前后的script_name和pathinfo部分 root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; fastcgi_param PATH_INFO $1; # 把pathinfo部分赋值给PATH_INFO变量 include fastcgi_params;&#125;Nginx与Rewrite规则Rewrite语法Rewrite正则表达式 定向后的位置 模式Goods-3.html ——&gt; Goods.php?goods_id=$1123456goods-([\d+])\.html ---&gt; goods.php?goods_id=$1location / &#123; index index.php rewrite goods-([\d]+)\.html$ /ecshop/goods.php?id=$1;&#125;注意:用url重写时，正则里如果有“{}”，正则要用双引号包起来。try_files当用户请求 http://localhost/example 时，这里的 $uri 就是 /example。try_files 会到硬盘里尝试找这个文件。如果存在名为 /$root/example（其中 $root 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户。显然，目录中没有叫 example 的文件。然后就看 $uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录。又找不到，就会 fall back 到 try_files 的最后一个选项 /index.php，发起一个内部 “子请求”，也就是相当于 nginx 发起一个 HTTP 请求到 http://localhost/index.php。1234location / &#123; try_files $uri /index.php?$uri;&#125;try_files方法让Ngxin尝试访问后面得$uri链接，并进根据@apache配置进行内部重定向。当然try_files也可以以错误代码赋值，如try_files /index.php = 404 @apache，则表示当尝试访问得文件返回404时，根据@apache配置项进行重定向。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 Nginx优化]]></title>
    <url>%2FNginx%2F966c5443.html</url>
    <content type="text"><![CDATA[Nginx反向代理与动静分离用nginx做反向代理用proxy_pass,以反向代理为例，nginx不自己处理图片的相关请求，而是把图片的请求转发给apache来处理。—这就是传说的“动静分离”，动静分离不是一个严谨的说法，叫反向代理比较规范。配置如下:123location ~ \.(jpg|jpeg|png|gif)$ &#123; proxy_pass HTTP://IP:PORT;&#125;思考:反向代理导致了后端服务器接到的客户端IP为前端服务器的IP，而不是客户真正的IP，怎么办?答: 代理服务器通过设置头信息字段，把用户的IP传递到后台服务器去。如:1234location ~ \.(jpg|jpeg|png|gif)$ &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass HTTP://IP:PORT;&#125;在apache的日志格式里加上X-Forwarded-For,如下:1LogFormat "%&#123;X-Forwarded-For&#125;i %l %u \"%r\" %&gt;s %b" common如果后端的服务器非常多，该如何写？又如何均匀的分发任务?（负载均衡）Nginx集群和负载均衡具体的负载均衡的方式注意:负载均衡是一种方案，实现办法有DNS轮询。如下图，DNS服务器允许一个域名有多个A记录。那么在用户访问时，一般按地域返回一个较近的解析记录。这样，全国不同的地区，看到的163的主页，来自不同的服务器。第二步:当解析出结果，比如浏览器连接60.217时，这台主机后面还有N台，也要做负载均衡。1) 硬件上做负载均衡，F5 BIG-IP，硬件负载均衡(很贵)直接从TCP/IP的底层协议上，直接做数据包的中转。2) 软件负载均衡,LVS3) 反向代理+负载均衡在nignx中做集群与负载均衡步骤都是一样的，Upstream{}模块把多台服务器加入到一个组，然后memcached_pass，fastcgi_pass, proxy_pass ==&gt; upstream组具体配置步骤:配置upstream1234upstream imageserver &#123; server 192.168.1.204:8080 weight=1 max_fails=2 fail_timeout=30s; server 192.168.1.204:8081 weight=1 max_fails=2 fail_timeout=30s;&#125;下游调用:1234location ~ \.(jpg|jpeg|png|gif)$ &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://imageserver;&#125;默认的负载均衡算的算法:是设置计数器，轮流请求N台服务器可以按照第3中模式，来利用不同参数把请求均衡到不同服务器去，如基于cookie值区别用户做负载均衡(nginx sticky模块)，或基于URI利用一致性哈希算法做均衡(NginxHttpUpstreamConsistentHash模块)或基于IP做负载均衡等。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 高级话题]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2Fe36135cb.html</url>
    <content type="text"><![CDATA[Redis事物什么是事物事物是指一系列操作步骤，这一系列的操作步骤，要么完全地执行，要么完全地不执行。Redis中的事物(transaction)是一组命令的集合，至少是两个或两个以上的命令，redis事物保证这些命令被执行时中间不会被任何其他操作打断。事物操作的命令multi语法: multi作用: 标记一个事物的开始。事物内的多条命令会按照先后顺序被放到一个队列当中。返回值: 总是返回OKexec语法: exec作用: 执行所有事物块内的命令返回值: 事物内的所有执行语句内容，事物被打断(影响)返回nildiscard语法: discard作用: 取消事物，放弃执行事物块内的所有命令返回值: 总是返回OKwatch语法: watch key [key···]作用: 监视一个(或多个)key，如果在事物执行之前这个(或这些)key被其他命令所改动，那么事物将被打断。返回值: 总是返回OKunwatch语法: unwatch作用: 取消WATCH命令对所有key的监视。如果在执行WATCH命令之后，EXEC命令或DISCARD命令先被执行了的话，那么就不需要在执行UNWATCH了返回值: 总是返回OK事物的实现正常执行事物事物的执行步骤: 首先开启事物，其次向事物队列中加入命令，最后执行事物提交。例1: 事物的执行：1) multi：用multi命令告诉Redis，接下来要执行的命令你先不要执行，而是把它们暂时存起来(开启事物)2) sadd works john 第一条命令进入等待队列(命令入队)3) sadd works rose 第二条命令进入等待队列(命令入队)4) exce 告知redis执行前面发送的两条命令(提交事物)查看works集合事物执行exec之前，入队命令错误(语法错误；严重错误导致服务器不能正常工作(例如内存不足)),放弃事物。执行事物步骤:1) MULTI 正常命令2) SET key value 正常命令3) INCR 命令语法错误4) EXEC 无法执行事物，那么第一条正确的命令也不会执行，所有key的值不会设置成功。结论: 事物执行exec之前，入队命令错误，事物终止，取消，不执行。事物执行exec命令后，执行队列命令，命令执行错误，事物提交执行步骤:1) MULTI 正常命令2) SET username zhangsan 正常命令3) lpop username 正常命令，语法没有错误，执行命令时才会有错误4) EXEC正常执行，发现错误可以在事物提交前放弃事物，执行discard结论: 在exec执行后的所产生的错误，即使事物中有某个/某些命令在执行时产生了错误，事物中的其他命令仍然会继续执行。Redis在事物失败时不进行回滚，而是继续执行余下的命令。Redis这种设计原则是: Redis命令只会因为错误的语法而失败(这些问题不能在入队时发现)，或是命令用在了错误类型的键上面，失败的命令并不是Redis导致，而是由编程错误造成的，这样的错误还应该在开发中被发现，生产环境中不应出现语法的错误。就是在程序的运行环境中不应该出现语法的错误。而Redis能够保证正确的命令一定会被执行。再者不需要对回滚进行支持，所以Redis的内部可以保持简单且快速。放弃事物1) MULTI开启事物2) SET age 35 命令入队3) SET age 30 命令入队4) DISCARD 放弃事物，则命令队列不会被执行例1:Redis的watch机制Redis的WATCH机制WATCH机制原理:WATCH机制: 使用WATCH监视一个或多个key，跟踪key的value修改情况，如果有ley的value值在事物EXEC执行之前被修改了，整个事物被取消。EXEC返回提示信息，表示事物已经失败。WATCH机制使的事物EXEC变得有条件，事物只有在被WATCH的key没有修改的前提下才能执行。不满足条件，事物被取消。使用WATCH监视了一个带过期时间的键，那么即使这个键过期了，事物任然可以正常执行。大多数情况下，不同的客户端会访问不同的键，相互同时竞争同一key的情况一般都很少，乐观锁能够以很好的性能解决数据冲突的问题。何时取消key的监视(WATCH)?1) WATCH命令可以被调用多次。对键的监视从WATCH执行之后开始生效，直到调用EXEC为止。不管事物是否成功执行，对所有键的监视都会被取消。2) 当客户端断开连接时，该客户端对键的监视也会被取消。3) UNWATCH命令可以手动取消对所有键的监视。WATCH的事例执行步骤:首先启动redis-server,在看起两个客户端连接。分别叫A客户端和B客户端。启动Redis服务器A客户端(红色): WATCH某个key，同时执行事务B客户端(黄色): 对A客户端WATCH的key修改其value值。1) 在A客户端设置key:str.lp登录人数为102) 在A客户端监视key:str.lp3) 在A客户端开启事物 multi4) 在A客户端修改 str.lp的值为115) 在B客户端修改 str.lp的值为156) 在A客户端执行事物 exec7) 在A客户端查看 str.lp的值，A客户端执行的事物没有提交，因为WATCH的str.lp的值已经被修改了，所以放弃事物。例1: 乐观锁持久化持久化概述持久化可以理解为存储，就是将数据存储到一个不会丢失的地方，如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化的，而放在磁盘就算是一种持久化。Redis的数据存储在内存中，内存是顺势的，如果linux宕机或重启，又或者Redis崩溃或重启，所有的内存数据都会丢失，为解决这个问题，Redis提供两种机制对数据进行持久化存储，便于发生故障后能迅速恢复数据。持久化方式RDB方式什么是RDB方式?Redis Database(RDB)，就是在指定的时间间隔内将内存中的数据集快照写入磁盘，数据恢复时将快照文件直接再读到内存。RDB保存了在某个时间点的数据集(全部数据)。存储在一个二进制文件中，只有一个文件。默认是dump.rdb。RDB技术非常适合做备份，可以保存最近一个小时，一天，一个月的全部数据。保存数据是在单独的进程中写文件，不影响Redis的正常使用。RDB恢复数据时比其他AOF速度快。如何实现?RDB方式的数据持久化，仅需在redis.conf文件中配置即可，默认配置是启用的。在配置文件redis.conf中搜索SNAPSHOTTING，查找在注释开始和结束文件的关于RDB的配置说明。配置SNAPSHOTTING的地方有三处。1) 配置执行RDB生成快照文件的时间策略。对Redis进行设置，让它在“N秒内数据集至少有M个key改动”这一条件被满足时，自动保存一次数据集。配置格式: save &lt;seconds&gt; &lt;changes&gt;save 900 1save 300 10save 60 100002) dbfilename： 设置RDB的文件名，默认文件名为dump.rdb3) dir: 指定RDB文件的存储位置，默认是./当前目录配置步骤:1) 查看ps -ef | grep redis, 如果服务启动，先停止。2) 修改redis.conf文件，修改前先备份，执行cp redis.conf redis.conf.bak查看默认启用的RDB文件3) 编辑redis.conf增加save配置，修改文件名等。vim redis.conf修改的内容:把原来的默认的dump.rdb删除，修改redis.conf后，重新启动redis4) 在20秒内修改三个key的值5) 查看生成的rdb文件总结优点: 由于存储的是数据快照文件，恢复数据很方便，也比较快缺点:1) 会丢失最后一次快照以后更改的数据。如果你的应用能容忍一定数据的丢失，那么使用rdb是不错的选择；如果你不能容忍一定数据的丢失，使用rdb就不是一个很好的选择。2) 由于需要经常操作磁盘，RDB会分出一个子进程。如果你的reids数据库很大的话，子进程占用比较多的时间，并且可能会影响Redis暂停服务一段时间(millisecond级别),如果你的数据库超级大并且你的服务器CPU比较弱，有可能是会达到一秒。AOF方式什么是AOF方式Append-only File(AOF)，Redis每次接受到一条改变数据的命令是，它将把该命令写到一个AOF文件中(只记录写操作，读操作不记录),当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。如何实现AOF方式的数据持久化，仅需在redis.conf文件中配置即可配置项:1) appendonly: 默认是no，改成yes即开启了aof持久化2) appendfilename: 指定AOF文件名，默认文件名为:appendonly.aof3) dir: 指定RDB和AOF文件存放的目录，默认是./4) appendfsync： 配置向aof文件写命令数据的策略:no： 不主动进行同步操作，而是完全交由操作系统来做(即每30秒一次)，比较快但不是很安全。always: 每次执行写入都会执行同步，慢一些但是比较安全。everysec: 每秒执行一次同步操作,比较平衡,介于速度和安全之间。这是默认项。5) auto-aof-rewrite-min-size： 允许重写的最小AOF文件大小，默认是64M。当aof文件大于64M时，开始整理aop文件，去掉无用的操作命令。缩小aop文件。例1:1) 停止运行的reids，备份要修改的redis.conf2) 查看redis安装目录/src下有无.aof文件。默认是在redis的当前目录3) 编辑redis.conf设置appendonly为yes即可。查看appendfsync的当前策略。查看appendfilename的文件名称。4) 在redis客户端执行 写入命令5) 查看aof文件总结1) append-only文件是另一个可以提供完全数据保障的方案2) AOF文件会在操作过程中变得越来越大。比如，如果你做一百次加法计算，最后你只会在数据库里面得到最终的数值，但是在你的AOF里面会存在100次记录，其中99条记录对最终的结果都是无用的；但Redis支持在不影响服务的前提下在后台重构AOF文件，让文件得以整理变小。3) 可以同时使用这两种当时，redis默认优先加载aof文件(aof数据最完整);主从复制主从复制–读写分离通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失(或少量丢失)数据，但是由于数据是存储在一台服务器上的，如果这台服务器出现故障，比如硬盘坏了，也会导致数据丢失。为了避免单点故障，我们需要将数据复制多份部署在多台不同的服务器上，即使有一台服务器出现故障其他扶我去依然可以继续提供服务。这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器上，那该怎么实现呢?Redis的主从复制。Redis提供了复制(replication)功能来自动实现多台redis服务器的数据同步(每天19点新闻联播,基本从cctv1-8，各大卫视都会播放)我们可以通过部署多台redis，并在配置文件中指定这几台redis之间的主从关系，主负责写入数据，同时把写入的数据实时同步到从机器，这种模式叫做主从复制，即master/slave,并且redis默认master用于写，slave用于读，向slave写数据会导致错误。Redis主从复制实现(master/salve)方式1: 修改配置文件，启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，从而构成主从复制的关系。方式2: ./redis-server -slaveof &lt;master-ip&gt; &lt;master-port&gt;,在启动redis时指定当前服务成为某个主Redis服务器的从Slave。方式1的实现步骤:模拟多Redis服务器，在一台已经安装Redis的机器上，运行多个Redis应用模拟多个Redis服务器。一个Master，两个Slave。新建三个Redis的配置文件如果Redis启动，先停止。作为Master的Redis端口是6380作为Slave的Redis端口分别是6382，6384从原有的redis.conf拷贝三份，分别命名为redis6380.conf,redis6382.conf, redis6384.conf编辑Master配置文件编辑Master的配置文件redis6380.conf: 在空文件加入如下内容include /usr/local/redis-3.2.9/redis.confdaemonize yesport 6380pidfile /var/run/redis_6380.pidlogfile 6380.logdbfilename dump6380.rdb配置项说明:include： 包含原来的配置文件内容。/usr/local/redis-3.3.9/redis.conf按照自己的目录设置。daemonize: yes 后台启动应用,相当于./redis-server &amp;， &amp;的作用。port: 自定义的端口号pidfile: 自定义的文件，表示当前程序的pid,进程id。logfile: 日志文件dbfilename: 持久化的rdb文件名编辑Slave配置文件编辑Slave的配置文件redis6382.conf和redis6384.conf： 在空文件加入如下内容1） redis6382.conf:include /usr/local/redis-3.2.9/redis.confdaemonize yesport 6382pidfile /var/run/redis_6382.pidlogfile 6382.logdbfilename dump6382.rdbslaveof 127.0.0.1 6380配置项说明:slaveof： 表示当前Redis是谁的从。当前是127.0.0.1 端口是6380这个Master的从。2） redis6384.conf:include /usr/local/redis-3.2.9/redis.confdaemonize yesport 6384pidfile /var/run/redis_6384.pidlogfile 6384.logdbfilename dump6384.rdbslaveof 127.0.0.1 6380启动服务器 Master/Slave都启动启动方式 ./redis-server 配置文件启动Redis，并查看启动进程查看配置后的服务信息命令:1) Reids客户端使用指定端口连接Redis服务器./redis-cli -p 端口2) 查看服务器信息info replication登录到Master: 6380查看当前服务信息在客户端的Redis内执行命令 info replicationMaster服务的查看结果:在新的Xshell窗口分别登录到6382，6384查看信息6384登录内容也同6382。向Master写入数据在6380执行flushall清除数据，避免干扰的测试数据。生产环境避免使用。在从Salve读数据6382,6384都可以读主Master的数据，不能写Salve写数据失败容灾处理当Master服务出现故障，需手动将slave中的一个提升为master，剩下的slave挂至新的master上(冷处理:机器挂掉了，再处理)命令:1) slaveof no one, 将一台slave服务器提升为Master(提升某slave为master)2) slaveof 127.0.0.1 6381 (将slave挂至新的master上)执行步骤:将Master:6380停止 (模拟挂掉)选择一个Slave升到Master，其它的Slave挂到新提升的Master将其它Slave挂到新的Master在Slave 6384身上执行现在的主(Master/Slave)关系: Master是6382， Slave是6384查看6382:原来的服务器重新添加到主从结构中6380的服务器修改后，从新工作，需要把它添加到现有的Master/Slave中先启动6380的Redis服务连接到6380端口当前服务挂到Master上查看新的Master信息在6382执行:现在的Master/Slave关系是:Master: 6382Slave: 6380Slave: 6384操作命令进入客户端需指定端口 ./redis-cli -p 6380不配置启动默认都是主masterinfo replication 查看redis服务器所处角色总结1) 一个master可以有多个slave2) salve下线，读请求的处理性能下降3) master下线，写请求无法执行4) 当master发生故障，需手动将其中一条slave使用slaveof no noe命令提示为master，其它slave执行slaveof命令指向这个新的master，从新的master处同步数据5) 主从复制模式的故障转移需要手动操作，要实现自动化处理，这就需要Sentinel哨兵，实现故障自动转移。高可用Sentinel哨兵Snentinel哨兵是redis官方提供的高可用方案，可用用它来监控多个Redis服务实例的运行情况。Redis Sendtinel是一个运行在特使模式下的Redis服务器。Redis Sentinel是在多个Sentinel进程环境下相互协作工作的。Sentinel系统有三个主要任务监控: Sentinel不断的检查主服务和从服务器是否按照预期正常工作。提醒: 被监控的Redis出现问题时，Sentinel会通知管理员或其他应用程序。自动故障转移: 监控的主Redis不能正常工作，Sentinel会开始进行故障迁移操作。将一个从服务器升级新的主服务器。让其他从服务器挂到新的主服务器。同时向客户端提供新的主服务器地址。Sentinel配置Sentinel配置文件复制三份Sentinel.conf文件:Sentinel系统默认port是26379。 三个配置port分别设置为26380， 26382， 26384。三个文件分别命名为:sentinel26380.confsentinel26382.confsentinel26384.conf执行复制命令 cp sentinel.conf xxx.conf三份sentinel配置文件修改:1) 修改port 26380、 port 26382、 port 263842) 修改sentinel monitor mymaster 127.0.0.1 6380 2格式: sentinel monitor &lt;name&gt; &lt;masterIP&gt; &lt;masterPort&gt; &lt;Quorum投票数&gt;Sentinel监控主(Master)Redis,Sentinel根据Master的配置自动发现Master的Slave，Sentinel默认端口号为26379。sentinel26380.conf1) 修改port2) 修改监控的master地址sentinel26382.conf 修改port 26382， master的port 6382sentinel26384.conf 修改port 26384， master的port 6382启动主从(Master/Slave) Redis启动Redis查看Master的配置信息连接到6382使用info命令查看Master/Slave启动Sentinelredis安装时make编译后就产生了redis-sentinel程序文件，可以在一个redis中运行多个sentinel进程。启动一个运行在Sentinel模式下的Redis服务实例./redis-sentinel sentinel配置文件执行以下三条命令，将创建三个监视主服务器的Sentinel实例./redis-sentinel ../sentinel26380.conf./redis-sentinel ../sentinel26382.conf./redis-sentinel ../sentinel26384.conf在XShell开启三个窗口分别执行:主Redis不能工作让Master的Redis停止服务，执行shutdown先执行info replication确认Master的Redis，在执行shutdown查看当前Redis的进程情况Sentinel起的作用在Master执行shutdown后，稍微等一会Sentinel要进行投票计算，从可用的Slave选举新的Master。查看Sentinel日志，三个Sentinel窗口的日志是一样的。查看新的Master查看原Slave的变化新的Redis加入Sentinel系统，自动加入Master重新启动6382查看6384的信息测试数据：在Master写入数据在6382写入数据，不能写入监控1) Sentinel会不断检查Master和Slave是否正常。2) 如果Sentinel挂了，就无法监控，所以需要多个哨兵，组成Sentinel网络，一个健康的Sentinel至少有3个应用。彼此在独立的物理机器或虚拟机。3) 监控同一个Master的Sentinel会自动连接，组成一个分布式的Sentinel网络，互相通信并交换彼此关于被监控服务器的信息。4) 当一个Sentinel认为被监控的服务器已经下线时，它会向网络中的其它Sentinel进行确认，判断该服务器是否真的已经下线。5) 如果下线的服务器为主服务器，那么Sentinel网络将对下线主服务器进行自动故障转移，通过将下线的主服务的某个服务器提升为新的主服务器，并让其从服务器转移到新的主服务器下，以此来让系统重新回到正常状态。6) 下线的旧主服务器重新上线，Sentinel会让它成为从，挂到新的主服务器下。总结主从复制，解决了读请求的负担，从节点下线，会使得读请求能力有所下降，Master下线，写请求无法执行。Sentinel会在Master下线后自动执行故障转移操作，提升一台Slave为Master，并让其它Slave成为新的Master的Slave。安全设置设置密码访问Redis默认是没有密码的，这样不安全，任意用户都可以访问。可以启动使用密码才能访问Redis。设置Redis的访问密码，修改redis.conf中这行requirepass密码。密码要比较复杂，不容易破解，而且需要定期修改。因为redis速度相当快，所以在一台比较好的服务器下，一个外部用户可以再一秒钟进行150K次的密码尝试，需要指定非常非常强的密码来防止暴力破解。开启访问密码设置修改redis.conf，使用vim命令。找到requirepass行去掉注释，requirepass空格后就是密码。例1: 设置访问密码是123456，这是练习使用，生产环境要设置复杂的密码修改redis.conf，文件480行左右。原始内容:修改后:查看修改结果:访问有密码的Redis如果Redis已经启动，关闭后重新启动。访问有密码的Redis两种方式:1) 在连接到客户端后,使用命令auth 密码，命令执行成功后，可以正常使用Redis2) 在连接客户端时使用-a密码。例如./redis-cli -h ip -p port -a password启动Redis使用1)访问输入命令auth密码使用2)方式绑定ip修改redis.conf文件，把# bind 127.0.0.1前面的注释#去掉，然后把127.0.0.1改成允许访问你redis服务器的ip地址，表示只允许该ip进行访问。多个ip使用空格分割。例如 bind 192.168.1.100 192.168.1.10修改默认端口修改redis的端口，这一点很重要，使用默认的端口很危险，redis.conf中修改port 6379将其修改为自己指定的端口(可随意),端口1024是保留给操作系统使用的。用户可以使用的范围是1024-65535使用 -p 参数指定端口，例如: ./redis-cli -p 新设置端口]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 Nginx介绍]]></title>
    <url>%2FNginx%2Ff8a6e8f7.html</url>
    <content type="text"><![CDATA[Nginx介绍Nginx(发音同engine x)是一款轻量级的Web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器。最早由俄罗斯的程序设计师Igor SYsoev所开发，并在一个BSD-like协议下发行。其特点是轻量级,占有内存少，并发能力强，目前发展势头强劲。web领域最经典的lamp组合已经变成lnmp组合。注：开源协议:GPL(带有病毒性质，使用GPL必须以GPL开源)、BSD(可以商用，相对宽松)、apache。谁在用Nginx目前国内的一线门户网站，如网易、搜狐、腾讯。以及大量新兴网站，如自学it网、豆瓣。Nginx的占有率变化下图是世界范围内，排名前1000,10000的网站的webserver比例Apache占有率高主要是历史原因。因为网站一旦运行，不轻易更换。Nginx编译与启动编译安装到官方网站:http:/nginx.org寻找最新stable版下载。例如当前最新的http://nginx.org/download/nginx-1.15.9.tar.gz安装准备:nginx依赖于pcre库，要先安装pcre1234567# yum install pcre pcre-devel# cd /usr/local/src# wget http://nginx.org/download/nginx-1.15.9.tar.gz# tar -zxvf nginx-1.15.9.tar.gz# cd nginx-1.15.9# ./configure --prefix=/usr/local/nginx# make &amp;&amp; make install为什么要先装pcre?因为:nginx要在rewrite是要解析正则表达式,PCRE是正则解析库。nginx目录介绍cd /usr/local/nginx，看到如下4个目录conf: 配置文件html: 网页文件logs: 日志文件sbin: 主要二进制程序启动nginx12cd /usr/local/nginx./sbin/nginx如果没有出现错误提示，则启动成功了。如果有错误提示，则根据错误提示再做处理，常见的错误是“80端口被占用”。80端口被占用的解决方案如果出现不能绑定80端口，80端口已经被占用。(有时候是自己安装了apache,nginx等，还有更多情况是操作系统自带了apche并作为服务启动)解决:把占用80端口的软件或服务关闭即可。如果是linux系统自带的apache且自动启动。service httpd stop如果是自行编译安装的，可以# /path/to/apacht/bin/apachctl stop如果检测确实没有其他程序占据80端口，但仍报此错，则问题可能是因为Nignx试图同时监听IPV4和IPV6的80端口导致的的(Nginx 1.4.0版本曾有此问题)1234server &#123; listen： 80 listen [::]:80;&#125;可以按如下2种办法修改1234server &#123; listen 80; listen [::]:80 ipv6pnly=on;&#125;或者123server &#123; listen [::]:80;&#125;Nginx 命令参数kill -INT 17800kill -USR1如果不愿意用信号来控制，nginx程序也可以用一些参数，达到效果。如：nginx -t 作用：测试配置是否正确nginx -s reload 作用：加载最新配置nginx -s stop 作用：立即停止(停止请求立即停止)nginx -s quit 作用：优雅停止(请求结束然后停止)nginx -s reopen 作用：重新打开日志]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 Redis数据类型操作命令]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2F5d009d9f.html</url>
    <content type="text"><![CDATA[Redis数据类型操作命令字符串类型 (string)字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，序列化后的数据，JSON化的对象，甚至是一张图片。基本命令先测试能连接到redis服务器set将字符串值value设置到key中语法:set key value查看已经插入的key向已经存在的key设置新的value，会覆盖原来的值get获取key中设置的字符串值语法:get key例如:获取username这个key对应的valueincr将key中存储的数字值加1，如果key不存在，则key的值先被初始化为0再执行incr操作(只能对数字类型的数据操作)语法: incr key例1:操作key值增加1例2:对非数字的值操作是不行的decr将key中存储的数字值减1，如果key不存在，那么key的值先被初始化为0再执行decr操作(只能对数字类型的数据操作)语法: decr key例1： 不存在的key，初始值为0，在减1。例2:对存在的数字值得key，减1。先执行incr index，增加到3incr,decr在实现关注人数上，文章的点击数上。append语法: append key value说明: 如果key存在，则将value追加到key原来旧值得末尾如果key不存在，则将key设置值为value返回值: 追加字符串之后的总长度例1:追加内容到存在的key例2:追加到不存在的key，同set key value常用命令strlen语法: strlen key说明: 返回key所存储的字符串值的长度返回值:1) 如果key存在，返回字符串值的长度2）如果key不存在，返回0例1:计算存在key的字符串长度设置中文set k4中文长度，按字符个数计算例2:计算不存在的keygetrange语法:getrange key start end作用:获取key中字符串值从start开始到end结束的字符串，包括start和end，负数表示从字符串的末尾开始，-1表示最后一个字符。返回值:截取的字符串使用的字符串 key:school, value:bjpowernode例1:截取从2到5的字符串例2:从字符串尾部截取,start,end是负数,最后一位是-1例3:超出字符串范围的截取，获取合理的字符串。setrange语法: setrange key offset value说明: 用value覆盖(替换)key的存储的值从offset开始，不存在的key做空白字符串。返回值: 修改后的字符串的长度。例1:替换给定的字符串例2:设置不存在的keymset语法: mset key value[key value···]说明: 同时设置一个或多个key-value对返回值: OK例1:一次设置多个key, valuemget语法: mget key[key ···]作用: 获取所有(一个或多个)给定key的值返回值: 包含所有key的列表例1:返回多个key的存储值例2:返回不存在的key哈希类型 hashredis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。基本命令hset语法:hset hash表的key feld value作用:将哈希表key中的域field的值设为vlaue，如果key不存在，则新建hash表，执行赋值，如果有field，则覆盖值。返回值:1) 如果field是hash表中新field，且设置值成功，返回12）如果field已经存在，旧值覆盖新值，返回0例1：新的field例2：覆盖旧的fieldhget语法: hget key field作用: 获取哈希表key中给定域field的值返回值: field域的值,如果key不存在或者field不存在返回nil例1:获取存在key值得某个域的值例2:获取不存在的fieldhmset语法: hmset key field value [field value···]说明: 同时将多个field-value（域-值）设置到哈希表key中，此命令会覆盖已经存在的field,hash表key不存在，创建空的hash表，执行hmset。返回值:设置成功返回OK，如果失败返回一个错误。例1:同时设置多个field-value使用redis-desktop-manager工具查看hash表，website的数据结构例2:key类型不是hash，产生错误。hmget语法: mhget key field[field ···]作用: 获取哈希表key中一个或多个给定域的值返回值: 返回和field顺序对应的值，如果field不存在，返回nil例1:获取多个field的值hgetall语法: hgetall key作用: 获取哈希表key中所有的域和值返回值:以列表形式返回hash中域和域的值，key不存在，返回空hash例1:返回key对应的所有域和值例2:不存在的key，返回空列表hdel语法: hdel key field[field ···]作用: 删除哈希表key中的一个或多个指定域field，不存在field直接忽略返回值:成功删除的field的数量例1:删除指定field常用命令hkeys语法: hkeys key作用: 查看哈希表key中的所有field域返回值: 包含所有field的列表，key不存在返回空列表例1:查看website所有的域名称:hvals语法: hvals key作用: 返回哈希表中所有域的值返回值: 包含哈希表所有域值的列表,key不存在返回空列表。例1:显示website哈希表所有域的值hexists语法: hexists key field作用: 查看哈希表key中，给定域field是否存在返回值: 如果field存在，返回1，其他返回0例1:查看存在key中的field域是否存在列表 listRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)基本命令lpush语法: lpush key value [value ···]作用: 将一个或多个值value插入到列表key的表头(最左边)，从左边开始加入值，从左到右的顺序依次插入到表头返回值: 数字，新列表的长度例1:将a,b,c插入到mylist列表类型在redis-desktop-manager显示插入图示:例2:插入重复值到list列表类型在redis-desktop-manager显示rpush语法: rpush key value [value···]作用: 将一个或多个值value插入到列表key的表尾(最右边)，各个value值按从左到右的顺序依次插入到表尾。返回值: 数字,新列表的长度例1: 插入多个值到列表在redis-desktop-manager显示lrange语法:lrange key start stop作用:获取列表key中指定区间内的元素，0表示列表的第一个元素，以1表示列表的第二个元素；start，stop是列表的下标值，也可以负数的下标，-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。start,stop超出列表的范围不会出现错误。例1:返回列表的全部内容lindex语法: lindex key index作用: 获取列表key中下标为指定index的元素，列表元素不删除，只是查询。0表示列表的第一个元素，以1表示列表的第二个元素；start，stop是列表的下标值，也可以负数为下标，-1表示类别的最后一个元素，-2表列表的倒数第二个元素，一次类推。返回值: 指定下标的元素；index不在列表范围，返回nil例1:返回下标是1的元素例2:不存在的下标llen语法: llen key作用: 获取列表key的长度返回值: 数值，列表的长度；key不存在返回0例1:显示存在key的列表元素的个数常用命令lrem语法: lrem key count value作用: 根据参数count的值，溢出列表中与参数value相等的元素，count&gt;0,从列表的左侧向右开始移除；count&lt;0从列表的尾部开始移除;count=0移除表中所有与value相等的值。返回值: 数值，移除的元素个数例1:删除2个相同的列表元素例2:删除列表中所有的指定元素，删除所有的javalset语法: lset key index value作用: 将列表key下标为index的元素的值设置为value。返回值: 设置成功返回OK；key不存在或者index超出范围返回错误信息。例1:设置下标2的value为”c”linsert语法: linsert key BEFORE|ALFTER pivot value作用: 将值value插入到列表key当中位于值pivot之前或之后的位置。key不存在，pivot不在列表中，不执行任何操作。返回值: 命令执行成功，返回新列表的长度，没有找到pivot返回-1，key不存在返回0。例1:修改列表arch，在值dao之前加入service例2:操作不存在的pivot集合类型 setRedis的Set是string类型的无序集合，集合成员是唯一的，即集合中不能出现重复的数据基本命令sadd语法: sadd key member [member···]作用: 将一个或多个member元素加入到集合key当中，已经存在于集合的member元素将被忽略，不会再加入。返回值: 加入到集合的新元素的个数。不包括被忽略的元素。例1:添加单个元素例2:添加多个元素smembers语法: smembers key作用: 获取集合key中的所有成员元素，不存在的ky视为空集合例1: 查看集合的所有元素例2: 查看不存在的集合sismember语法: sismember key member作用: 判断member元素是否是集合key的成员返回值: member是集合成员返回1，其他返回0。例1: 检查元素是否存在集合中scard语法: scard key作用: 获取集合里面的元素的个数返回值: 数字，key的元素个数。其他情况返回0。例1: 统计集合的大小例2: 统计不存在的keysrem语法: srem key member [member···]作用: 删除集合key中的一个或多个member元素，不存在的元素被忽略。返回值: 数字，成功删除的元素个数，不包括被忽略的元素。例1:删除存在的一个元素，返回数字1例2:删除不存在的元素常用命令srandmember语法: srandmember key[count]作用: 只提供key，随机返回集合中一个元素，元素不删除，依然在集合中；提供了count时，count是正数，返回包含count个数元素的集合，集合元素各不相同。count是负数，返回一个count绝对值的长度的集合，集合中元素可能会重复多次。返回值: 一个元素；多个元素的集合。例1: 随机显示集合的一个元素例2: 使用count参数，count是正数例3: 使用count参数，count是负数spop语法: spop key [count]作用: 随机从集合中删除一个元素，count是删除的元素个数。返回值: 被删除的元素，key不存在或空集合返回nil例1: 随机从集合删除一个元素例2: 随机删除指定个数的元素有序集合类型 zset (sorted set)Redis有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员。不同的是zset的每个元素都会关联一个分数(分数可以重复)，redis通过分数来为集合中的成员进行从小到大的排序。基本命令zadd语法: zadd key score member [score member···]作用: 将一个或多个member元素及其score值加入到有序集合key中，如果member存在集合中，则更新值；score可以是整数或浮点数。返回值: 数字，新添加的元素个数例1: 创建保存学生成绩的集合例2: 使用浮点数作为scroezrange语法: zrange key start stop [WITHSCORES]作用: 查询有序集合，指定区间的内的元素。集合成员按score值从小到大来排序。start,stop都是从0开始。0是第一个元素，1是第二个元素，一次类推。以-1表示最后一个成员，-2表示倒数第二个成员。WITHSCORES选项让score和value一同返回。返回值: 自定区间的成员集合例1: 显示集合的全部元素，不显示score，不使用WITHSCORES例2: 显示集合全部元素，并使用WITHSCORES例3: 显示第0,1二个成员例4: 排序显示浮点数的scorezrevrange语法: zrevrange key start stop [WITHSCORES]作用: 返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。其它同zrange命令。返回值: 自定区间的成员集合。例1: 成绩榜zrem语法: zrem key member [member···]作用: 删除有序集合key中的一个或多个成员，不存在的成员被忽略返回值: 被成功删除的成员数量，不包括被忽略的成员。例1: 删除指定一个成员wangwuzcard语法: zcard key作用: 获取有序集key的元素成员的个数返回值: key存在返回集合元素的个数，key不存在，返回0。例1: 查询集合的元素个数常用命令zrangebyscore语法: zrangebyscore key min max [WITHSCORES] [LIMIT offset count]作用: 获取有序集key中，所有score值介于min和max之间(包括min和max)的成员，有序成员是按递增(从小到大)排序。min,max是包括在内，使用符合(表示不包括。min, max可以使用-inf， +inf表示最小和最大。 limit用来限制返回结果的数量和区间。 withsocres显示score和value。返回值: 指定区间的集合数据。使用的准备数据例1: 显示指定具体区间的数据例2: 显示指定具体区间的集合数据，开区间(不包括min,max)例3: 显示整个集合的所有数据例4: 使用limit增加新的数据:显示从第一个位置开始，取第一个元素。zrevrangebyscore语法: zrevrangebyscore key max min[WITHSCORES] [LIMIT offset count]作用: 返回有序集key中，score值介于max和min之间(默认包括等于max或min)的所有的成员。有序集成员按score值递减(从大到小的次序排列)。其他同zrangebyscore例1: 查询工资最高到3000之间的员工zcount语法: zcount key min max作用: 返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员的数量例1: 求工资在3000-5000的员工数量]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Redis安装和使用]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2F3f361f63.html</url>
    <content type="text"><![CDATA[Redis安装和使用Redis是当今非常流行的基于KV结构的作为Cache使用的NoSQL数据库Redis介绍Remote Dictionary Server(Redis)是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的Key——Value数据库。Key字符串类型，其值(value)可以是字符串(String),哈希(Map),列表(list),集合(Sets)和有序集合(sorted sets)等类型，每种数据类型有自己专属命令。所以它通常也被称为数据结构服务器。Redis的作者是Salvatore Sanfillippo,来自意大利的西西里岛，现在居住在卡塔尼亚。目前供职于Pivotal公司(Pivotal是Spring框架的开发团队)，Salvatore Sanfilippo被称为Redis之父。官网:https://redis.io/中文:http://www.redis.cn/Redis的历史:2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人Salvatore Sanfilippo便开始对MySQL的性能感到失望,于是他决定亲自为LLOOGG量身定做一个数据库，并与2009年完成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望让更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。Sanfilippo Salvatore自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。2012年数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、知乎，国外如GitHub、Stack Overflow、Flickr、暴雪和Instagram，都是Redis的用户。VMware公司从2010年开始赞助Redis的开发，Salvatore Sanfilippo和Pieter Noordhuis也分别于同年的3月和5月加入VMware，全职开发Redis。Redis的代码托管在Github上https://github.com/antirez/redis,开发十分活跃，代码量只有三万多行。Windows 上安装RedisWindows版本的Redis是Microsoft的开源部门提供的Redis。这个版本的Redis适合开发人员学习使用，生产环境中使用Linux系统上的Redis。下载官网:https://redis.io/windows版本:https://github.com/MSOpenTech/redis/releases安装下载的Redis-x64-3.2.100.zip解压后，放到某个目录(例如D:\redis\),即可使用。目录结构:启动A、 Windows7系统双击redis-server.exe启动RedisB、 Win10系统有的机器双击redis-server.exe执行失败，找不到配置文件，可以采用以下执行方式：在命令行(cmd)中按如下方式执行D:\Redis&gt;redis-server.exe redis.windows.conf如图:关闭按ctrl+c退出Redis服务程序。添加到服务添加：redis-server.exe –service-install redis.windows.conf –service-name redis –port 6379删除:sc delete redis启动:net start redis停止:net stop redis当然，由于windows版本redis出现的背景原因，建议在windows下只是测试和学习使用，生产环境最好还是在linux系统下使用。Linux 上安装Redis下载wget http://download.redis.io/releases/redis-5.0.3.tar.gz安装解压缩redis-5.0.3.tar.gz到usr/local目录查看解压缩后的文件编译Redis文件，Redis是使用C语言编写的。会使用gcc编译器。在解压后的Redis目下执行(cd /usr/local/redis-5.0.3)make命令。注意事项:1) make命令执行过程中可能保存，根据控制台数据的错误信息进行解决2) 错误一： gcc命令找不到，是由于没有安装gcc导致解决方式:安装gcc编译器后在执行make命令。什么是gcc?gcc是GNU compiler collection的缩写，它是linux下一个编辑器集合(相当于javac)，是c或c++程序的编译器。怎么安装gcc？使用yum进行安装gcc。执行命令： yum -y install gcc3) 错误二： error：jemalloc/jemalloc.h: No such file or directory解决方式执行make MALLOC=libc开始执行make注意:在make执行之后再执行make install,该操作则将src下的许多可执行文件复制/usr/local/bin目录下，这样做可以在任意目录执行redis的软件的命令(例如启动,停止，客户端连接服务器等)，make install可以不用执行，看个人习惯。查看make编译结果，cd src目录cd src在执行ls启动Redis前台启动 ./redis-server后台启动 ./redis-server &amp;查看redis启动进程 ps -ef | grep redis关闭Redis关闭方式:1) 使用redis客户端关闭，向服务器发出关闭命令。切换到redis-3.2.9/src/目录，执行./redis-cli shutdown推荐使用这种方式，redis先完成数据操作，然后再关闭。例如:2) kill pid或者kill -9 pid这种不会考虑当前应用是否有数据库正在执行操作，直接就关闭应用。先使用ps -ef | grep redis查出进程号，在使用kill pidRedis客户端Redis客户端是一个程序，通过网络连接到Redis服务器，在客户端软件中使用Redis可以识别的命令，向Redis服务器发送命令，告诉Redis想要做什么。Redis把处理结果显示在客户端界面上。通过Redis客户端和Redis服务器交互。Redis客户端发送命令，同时显示Redis服务器的处理结果。redis命令行客户端：redis-cli(Redis Command Line Interface)是Redis自带的基于命令行的Redis客户端，用于与服务器端交互，我们可以使用该客户端来执行redis锋各种命令。两种常用的连接方式:A、 直接连接redis(默认ip127.0.0.1，端口6379)： ./redis-cli在redis安装目录\src,执行./redis-cli此命令式连接本机127.0.0.1，端口6379的redisB、 指定IP和端口连接redis: ./redis-cli -h 127.0.0.1 -p 6379-h redis 主机 IP(可以指定任意的redis服务器)-p 端口号(不同端口表示不同的应用)redis远程客户端Redis Desktop Manager： C++编写，响应迅速，性能好。官网地址： https://redisdesktop.com/github： https://github.com/uglide/RedisDesktopManager使用文档： http://docs.redisdesktop.com/en/latest/点击 “DOWNLOAD”安装客户端软件在windows系统使用此工具，连接Linux上或Windows上的Redis,双击此exe文件执行安装。安装后启动界面:使用客户端连接Linux的Redis连接Linux的Redis之前需要修改Redis服务器的配置信息。Redis服务器有安全保护措施，默认只有本机(安装Redis的那台机器)能够访问。配置信息存放在Redis安装目录下的redis.conf文件。修改此文件的两个设置。远程连接redis需要修改redis注目下的redis.conf配置文件:1) bing ip 绑定ip此行注释2）protected-mode yes 保护模式改为no使用vim命令修改redis.conf文件，修改此文件前备份此文件，执行cp命令执行vm redis.conf使用redis.conf启动redis修改配置文件后，需要使用配置文件重新启动Redis，默认不加载配置文件。先关闭已启动的Redis，使用一下命令启动Redis在Redis安装目录执行:./redis-server ../redis.conf &amp;配置Redis Desktop Manager(RDM),连接Redis在RDM的主窗口，点击左下的”Connect to Redis Server”连接成功后:redis编程客户端Jedisredis的Java编程客户端，Redis官方首先推荐使用Jedis，jedis是一个很小但很健全的redis的Java客户端。通过Jedis可以像使用Redis命令行一样使用Redis。jedis完全兼容redis 2.8.x and 3.x.xjedis源码： https://github.com/xetorthio/jedisapi文档: http://xetorthio.github.io/jedis/redis的其他编程语言客户端C、C++、C#、Erlang、Lua、Objective-C、Perl、PHP、Python、Ruby、Scala、Go等40多种语言都有连接redis的编程客户端。Redis的基本操作命令redis默认为16个库(在redis.conf文件可以配置，该文件很重要，后续很多操作都是这个配置文件)redis默认自动使用0号库。沟通命令，查看状态redis&gt;ping 返回PONG解释: 输入ping，redis给我们返回PONG，表示redis服务运行正常。查看当前数据库中的key的数目：dbsize语法:dbsize作用:返回当前数据库的key的数量。返回值:数字，key的数量例:先查索引5的key个数，在查0库的key个数redis默认使用16个库Redis默认使用16个库，从0到15。对数据库个数的修改，在redis.conf文件中databases 16切换库命令: select db使用其他数据库，命令是select index例如:select 5删除当前库的数据:flushdbredis自带的客户端退出当前redis连接:exit或quitRedis的Key的操作命令keys pattern作用: 查找所有符合模式pattern的key。pattern可以使用通配符。通配符:*:表示0-多个字符，例如：keys *查询所有key。？:表示单个字符，例如：wo？d，匹配word，wood等。例1:显示所有的key例2:使用*表示0或多个字符例3:使用？表示单个字符exists语法:exists key [key···]作用:判断key是否存在返回值:整数，存在key返回1，其他返回0。使用多个key，返回存在的key的数量。例1:检查指定key是否存在例2:检查多个keyexpire语法:expire key seconds作用:设置key的生存时间，超过时间，key自动删除。单位是秒。返回值:设置成功返回数字1，其他情况是0。例1: 设置红灯的倒计时是5秒ttl语法:ttl key作用:以秒为单位，返回key的剩余生存时间(ttl:time to live)返回值:-1:没有设置key的生存时间，key永不过期。-2:key不存在数字:key的剩余时间，秒为单位。例1:设置redlight的过期时间是10s，查看剩余时间type语法:type key作用:查看key所存储值得数据类型返回值:字符串表示的数据类型none(key不存在)string(字符串)list(列表)set(集合)zset(有序集)hash(哈希表)例1:查看存储字符串的key: wood例2:查看不存在的keydel语法:del key [key···]作用:删除存在的key，不存在的key忽略。返回值:数字，删除的key的数量。例1:删除指定的keyRedis的5种数据类型字符串类型 string字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，序列化后的数据，JSON化的对象甚至是一张图片。最大512M。哈希类型 hashRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。列表类型 listRedis列表时简单的字符串类别，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。集合类型 setRedis的Set是string类型的无序集合，集合成员是唯一的，即集合中不能出现重复数据。有序集合类型 zset(sorted set)Redis有序集合zset和集合set一样是string类型元素的集合，且不允许重复的成员。不同的是zset的每个元素都会关联一个分数(分数可以重复)，redis通过分数来为集合中的成员进行从小到大的排序。]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1课 flowable]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C%E6%B5%81%2FFlowable%2Fa30db437.html</url>
    <content type="text"><![CDATA[Shiro简介Apache Shiro是Java的一个安全(权限)框架。Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以完成：认证、授权、加密、会话管理、与Web集成、缓存等。下载: http://shiro.apache.org/]]></content>
      <categories>
        <category>工作流</category>
        <category>Flowable</category>
      </categories>
      <tags>
        <tag>Flowable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2课 flowable工作流概念]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C%E6%B5%81%2FFlowable%2F759ef6d2.html</url>
    <content type="text"><![CDATA[Shiro简介Apache Shiro是Java的一个安全(权限)框架。Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以完成：认证、授权、加密、会话管理、与Web集成、缓存等。下载: http://shiro.apache.org/]]></content>
      <categories>
        <category>工作流</category>
        <category>Flowable</category>
      </categories>
      <tags>
        <tag>Flowable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 NoSQL]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2F2f5b619.html</url>
    <content type="text"><![CDATA[NoSQL什么是NoSQLNoSQL = Not Only SQL(不仅仅是SQL),也解释为non-relational(非关系型数据库)。在NoSQL数据库中数据之间是无联系的，无关系的。数据的结构是松散的，可变的。为什么使用NoSQL关系型数据库的瓶颈:1) 无法应对每秒上万次的读写请求，无法处理大量集中的高并发操作。关系型数据的IO密集的应用。硬盘IO也变为性能瓶颈。2) 存储记录数量有限，横向可扩展能力有限，一张表最大两百多列。纵向数据可承受的能力也是有限的，一张表的数据到达百万级，读写的速度就会逐渐的下降。面对海量数据必须使用主从复制，分库分表。这样的系统架构是难以维护的。3) 无法简单地通过增加硬件、服务节点来提高系统性能。数据整个存储在一个数据库中的。多个服务器没有很好的解决办法，来复制这些数据。4) 关系型数据库大多是收费的，对硬件的要求比较高。软件和硬件的成本花费比较重大。NoSQL的优势(1) 大数据量，高性能NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。关系型数据库(例如MySQL)使用查询缓存。这种查询缓存在更新数据库后，缓存就是失效的。在频繁的数据读写交互应用中。缓存的性能不高。NoSQL的缓存性能要高的多。(2) 灵活的数据模型NoSQL无需事先为要缓存的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。尤其在快速变化的市场环境中，用户的需求总是在不断变化的。(3) 高可用NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。NoSQL能很好的解决关系型数据库扩展性差的问题。弥补了关系数据库(比如MySQL)在某些方面的不足，在某些方面能极大的节省开发成本和维护成本。MySQL和NoSQL都有各自的特点和使用的应用场景，两者结合使用。让关系数据库关注在关系上，NoSQL关注在存储上。(4) 低成本这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本。NoSQL的劣势(1) 无关系，数据之间是无联系的。(2) 不支持标准的SQL，没有公认的NoSQL标准。(3) 没有关系型数据库的约束，大多数也没有索引的概念。(4) 没有事务，不能依靠事务实现ACID。(5) 没有丰富的数据类型(数值，日期，字符，二进制，大文本等)]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 VMware Workstation Pro网络Nat模式配置]]></title>
    <url>%2FLinux%2F8592866f.html</url>
    <content type="text"><![CDATA[VMware Workstation Pro网络Nat模式配置前景我的目标是虚拟机可以上外网并且可以和主机进行通信，主机可以和虚拟机通信，和主机在局域网的机器可以通过端口转换访问主机的虚拟机中的机器。由于桥接模式必须主机电脑连接网路由于我电脑偶尔会在断网情况下工作，因此这里只能选择Nat模式。主机:主机电脑IP地址为:192.168.1.25(这个其实并不影响什么)虚拟机： 默认网关192.168.6.2虚拟机01： 192.168.6.3虚拟机02： 192.168.6.4虚拟机03： 192.168.6.5···Mware Workstation Pro网络Nat模式配置首先，点击编辑按钮，选择虚拟机网络编辑器。如下图:其次,选择VMnet8，修改类型为Nat模式，更改子网IP，点击更改设置，设置子网IP为:192.168.6.0, 子网掩码为:255.255.255.0然后，修改默认网关（一般情况下修改好子网IP后默认网关自动回配置好）。点击Nat设置，修改网关IP为192.168.6.2即可。主机局域网内访问虚拟机应用我在虚拟机里通过Gogs搭建了一个git服务器，虚拟机环境为centos6，设置的静态IP地址为:192.168.6.3。主机可以通过http://192.168.6.3:10000去访问我的git仓库，但是主机同局域网内的其他机器则不能访问。因此，我需要配置端口转发功能。点击Nat设置，在端口转发下面选择添加，主机端口选择一个没有应用占用的端口即可，这里我选择9999，类型选择TCP，虚拟机IP地址这里我自然选择192.168.6.3，可以填或者不写，这里描述我简单写为Gogs搭建的git仓库，然后点击确定就好。最后测试，主机内局域网的机器顺利通过192.168.1.25:9999访问虚拟机（192.168.6.3:10000）中的gogs服务。注意：192.168.1.25是我当前主机的IP的值，可通过IpConfig查看当前IP4地址。当前，主机也可以通过http://192.168.1.25:9999或者http://192.168.6.3:10000，或者http://127.0.0.1:9999进行访问Gogs应用。确保Windows服务启动项中，“VMware DHCP Service”、”VMware NAT Service”，两项服务是否启动Linux下静态IP配置cenots7.6下静态IP配置首先，编辑etc/sysconfig/network-scripts/ifcfg-ens33文件[caifenglin@caifenglin /]$ vim etc/sysconfig/network-scripts/ifcfg-ens33TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=7533c908-1b34-4d82-a7f2-ab7bd4ac8838DEVICE=ens33ONBOOT=yesIPADDR=192.168.6.4NETMASK=255.255.255.0NETWORK=192.168.6.2DNS1=192.168.1.1DNS2=8.8.8.8其次,修改/etc/sysconfig/network,配置网关，否则无法上网[caifenglin@caifenglin /]$ vim /etc/sysconfig/network#Created by anacondaNETWORKING=yesGATEWAY=192.168.6.2DNS1=192.168.1.1DNS2=8.8.8.8重启网路服务service network restartcentos6.9下配置静态IP首先，编辑etc/sysconfig/network-scripts/ifcfg-ens33文件[caifenglin@suixin network-scripts]$ vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0HWADDR=00:0C:29:97:FF:A5TYPE=EthernetUUID=56cd27b3-48e7-453e-a365-cf1075ad70e5ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.6.3NETMASK=255.255.255.0GATEWAY=192.168.6.2DNS1=192.168.1.1DNS2=114.114.114.114其次，修改/etc/resolv.conf 配置DNS[caifenglin@suixin network-scripts]$ vim /etc/resolv.conf# Generated by NetworkManagernameserver 192.168.1.1nameserver 114.114.114.114最后，重启网路服务运行”service network restart”命令，重启网络服务，使刚才修改的配置信息生效]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetty学习上]]></title>
    <url>%2FJetty%2F563c4e3.html</url>
    <content type="text"><![CDATA[Jetty大纲视图什么是Jetty?简单来讲 Jetty就是一个开源的HTTP服务器和Servlet引擎，它可以为JSP和Servlet提供运行时环境。比如Java Web应用最常见的Servlet容器Tomcat。由于其轻量级、灵活的特性，Jetty也被应用于一些知名产品中，例如ActiveMQ、Maven、Spark、GoogleAppEngine、Eclipse、Hadoop等。为什么使用Jetty?异步的Servlet，支持更高的并发量模块化的设计，更灵活，更容易定制，也意味着更高的资源利用率在面对大量的长连接的业务场景下，Jetty默认采用的NIO模型是更好的选择将Jetty嵌入到应用中，使一个普通应用可以快速支持http服务Jeety的基本架构Jetty的架构比较简单，核心组件主要是由Servlet和Handle组成。其中Server的Handler是其比较重要的一个数据模型，Jetty中所有的组件都是基于Handler。与tomcat对比Jetty比较容易贴合第三方框架，比如你可以直接用spring配置一个Jetty服务直接将Jetty作为提供HTTP服务的组件，嵌入到应用中Jetty是面向Handle的架构，而Tomcat是面向容器的架构Jetty默认采用NIO技术 ，而Tomcat默认是BIOJetty高度模块化，可以很灵活的管理扩展组件，而Tomcat对其他组件的管理则相对困难Tomcat架构图如下:使用Jetty]]></content>
      <categories>
        <category>Jetty</category>
      </categories>
      <tags>
        <tag>Jetty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专题:SVN版本控制技术]]></title>
    <url>%2FSVN%2Fa8d8e853.html</url>
    <content type="text"><![CDATA[第1章 SVN概述SVN简介什么是SVNSVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。SVN的作用使用SVN的目的主要有两个:实现项目组中的资源共享实现资源文件的版本控制SVN的工作原理Subversion是一个自由开源的版本控制系统。在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心版本库里，这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况，这样就可以借此将数据恢复到以前的版本，并可以查看数据的更改细节。正因为如此，许多人将版本控制系统当作一种神奇的“时间机器”。传统文件共享方式的弊端拷贝方式的弊端发送与接受文件的工作量巨大无法及时获取到更新对于之前版本的恢复较难,即使可以恢复，也大量浪费控件。若一个文件由多个修改，则会出现内容冲突问题。且难于确定修改的具体时间及修改人。······文件服务器的弊端空间大量浪费资源无法设定访问权限资源安全性很低发生冲突资源，无法自动合并·······SVN的体系结构图客户层GUI:图形化界面Command Line：命令行服务层http协议(需要Apache服务)svn协议仓库层FSFS(常用)Berkley DB(Oracle)SVN的下载下载页面链接:https://www.visualsvn.com/downloads/Apache-Subversion下载地址: Apache-Subversion-1.10.0.zip.VisualSVN-Server下载地址: VisualSVN-Server-3.8.1-x64.msi.第2章 SVN命令行的使用SVN的安装与配置SVN安装下载Apache-Subversion，并解压到D盘Subversion目录下，通过命令行提示符(管理员)及CMD命令，进入D盘下Subversion\bin目录，输入svn -h,如果出现如下图一串，说明SVN没有问题。SVN环境变量配置:SVN_HOME:D:\SubversionPath:%SVN_HOME%\binSVN常用命令SVN管理员命令svnadmin help查看所有管理员命令:svnadmin helpsvnadmin –version查看当前svn版本:svnadmin –versionsvnadmin help create查看当前命令如何使用:svnadmin help createsvnadmin create创建SVN版本仓库:svnadmin createSVN仓库分为两级：顶级仓库与根仓库该命令用于创建SVN版本仓库，确切说，创建的是根仓库。注意,在创建根仓库时，顶层仓库目录必须是存在的，其不会自动创建。根仓库目录是否存在，均是可以的。若根仓库目录不存在，命令会自动创建该根仓库。svn仓库目录结构svn仓库目录如下:conf：配置文件(svnserver.conf:连接仓库，authz：权限, passwd：密码, &gt;hooks-env.tmpl：钩子运行环境配置，可以实现客户端数据的自动更新功能)db: 具体版本内容(不存在冗余，以日志方式保存)hooks: 可以实现客户端数据的自动更新功能locks: 锁SVN服务端命令svnserve -dsvnserve -d 用于开启DOS系统下的SVN服务此守护线程监控着一个端口,即svn服务默认端口3690netstat -a 命令查看当前网络的连接状态。net statussvnserve -d –listen-port=8888可以看出，监听端口没有3690，而是8888svn://localhost:3690/ G:/ENML/SVNRepositories/test 等价于svn://localhost/ G:/ENML/SVNRepositories/testsvnserve -d –listen-port=8888 指定SVN服务占用的端口号为8888svn://localhost:8888/ G:/ENML/SVNRepositories/testsvnserve -d -r可以看到 G:/ENML/SVNRepositories/test这层目录暴露出来存在极大的安全隐患，但是顶层仓库是必须要告诉给客户端的我们可以用另外一个参数指定顶层仓库的位置，这样以后顶层仓库就不用再写了。svnserve -d -r G:/ENML/SVNRepositories 指定默认的SVN顶层仓库的路径。一旦指定，那么客户端在使用svn时直接跟仓库名即可。svn://localhost/test将SVN服务注册为开机自启动的windows服务sc create SVNService binpath=”D:/Subversion/bin/svnserve.exe –service -r G:/ENML/SVNRepositories” start=auto depend=Tcpip启动SVN服务: net start SVNService停止SVN服务: net stop SVNService删除SVN服务: sc delete SVNService(删除之前最好先停止系统服务)注意:该命令需要在具有管理员权限的窗口运行,win7、win8情况下”binpath=”后面需要跟一个空格。12345sc: server createbinpath：二进制程序执行命令及路径--service: Windows service mode (Service Control Manager)-r: 顶级仓库目录start: 启动模式，auto自启动SVN客户端命令svn checkoutcheckout,称为检出。其意义为:创建客户端指定目录与服务端指定仓库间的连接关系。客户端指定的这个目录，官方名称working copy，通常称为客户端连接目录。一个客户端一般情况下，只需要检出一次。A. 基于顶层仓库的checkout在任意目录下运行此命令：svn checkout svn://localhost/sms d:/course/svn/group/aacof其运行效果为,在aacof目录中出现一个.svn隐藏目录。svn checkout svn://localhost/sms若当前执行命令的目录为Working Copy目录，则运行以下命令后的结果为:在working copy中会出现根仓库目录，而根仓库目录中会存在.svn隐藏目录。B. 基于根仓库的checkout基于根仓库的服务创建无论是在任意目录运行checkout，还是在working copy中运行checkout，其运行效果是相同的，都是在working copy目录中产生一个.svn的隐藏目录。服务端修改客户端权限svn addA. add 文件当一个文件/目录，被存放到working copy中时，SVN并不会感知到它的存在，即SVN并不会对其进行管理。若要SVN对其进行管理，必须将其通知add命令，添加到SVN管理中。需要注意，(1) 被add的文件/目录，必须存在于woring copy中。(2) add命令的作用就是将制定文件/目录交由SVN进行管理，所以一个文件/目录一般情况下，就执行一次add命令即可。add命令的执行与文件是否被修改过没有任何关系。(3) 被add的目录，会将当前目录及其所包含的所有文件/目录，一次性B. add 目录add目录与add文件一样，即svn add 目录名svn commitcommit命令用于将客户端working copy中所有对文件/目录的操作提交到服务端。第3章 TortoiseSVN客户端第4章 Eclipse SVN客户端第5章 SVN与Apache服务整合]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn备份还原]]></title>
    <url>%2FSVN%2F6408e029.html</url>
    <content type="text"><![CDATA[备份:svnadmin dump D:\Repositories\TestProject &gt; D:\svndumpfile\TestProject_20090722.dump还原：1、将dump文件拷贝到目标机器2、在目标机器创建仓库：svnadmin create D:/repositories/TestProject并注意检查是否需要修改文件夹权限3、执行命令svnadmin load:svnadmin load D:/repositories/TestProject &lt; D:/TestProject_20090722.dump]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2Ff1601c3e.html</url>
    <content type="text"><![CDATA[单例模式总结一、概述单例模式(Singleton Pattern)是Java中最简单的设计模式之一这种类型的设计模式属于对象创建型模式作用：保证一个类仅有一个实例，并提供一个访问它的全局访问点。二、理解某些类创建对象是非常耗时耗内存和复杂的，这种类创建的对象我们称之为重量级对象(反之，轻量级对象)如果需要使用重量级类，一般吧这个类设计为单例对象模式，好处有：1)保证对象在内存中仅有一个，减少内存开销2)使用者不用考虑创建细节，使用方便3)可以控制对象的创建时刻代码实现的关键点:1)这个类在整个JVM中仅有一个对象实例对象的创建方式有：a)new –私有化构造器b)反射(reflect) –私有化构造器c)反序列化(deserialize) –不实现Serializable接口或者自定义反序列化的过程d)克隆(clone) –不实现Clonable或自定义克隆的过程2)提供一个访问它的全局访问点a)公开的静态变量(不利于扩展)b)一个公开的静态方法,返回唯一实例三、实现代码1)饿汉式-立即创建-线程安全2)懒汉式-延迟加载-线程不安全3)加锁的懒汉式-延迟加载-线程安全4)双重验证式懒汉式-延迟加载-线程安全-同步情况下效率高-现实复杂5)类加载方式-延迟加载-线程安全-同步情况下效率高-实现简单-不能防止反序列化6)枚举实现-立即加载-线程安全-实现简单-防止反序列化五、总结一般情况下，应该使用饿汉式(第一种方式)如果需要延迟加载，推荐使用类加载方式如果需要非常标准的单例模式(不能new，不能被反序列化),推荐使用枚举实现如果单例对象在创建过程中其他特殊的需求，可以考虑使用双重验证方式代码实现一、饿汉式-立即创建-线程安全饿汉式代码如下:123456789101112131415161718192021package 饿汉式;public class SingletonClass &#123; //创建唯一实例 private static final SingletonClass ONLY = new SingletonClass(); //构造方私有化，屏蔽外部的new private SingletonClass() &#123; &#125; //提供一个全局访问点 public static SingletonClass getInstance() &#123; //....其它代码 return ONLY; &#125; public void f() &#123; System.out.println("单例模式。。。。。。。。。。饿汉式"); &#125;&#125;测试类:123456789101112131415161718package 饿汉式;public class Main &#123; public static void main(String[] args) &#123; //SingletonClass a = new SingletonClass(); //a.f(); //SingletonClass a = SingletonClass.ONLY; //用户只能通过静态方法获取实例 SingletonClass a = SingletonClass.getInstance(); SingletonClass b = SingletonClass.getInstance(); System.out.println(a==b); a.f(); &#125;&#125;二、加锁的懒汉式-延迟加载-线程安全懒汉式核心代码(未加锁的懒汉式略):12345678910111213141516171819202122232425package 懒汉式;public class SingletonClass &#123; //创建唯一实例 private static SingletonClass ONLY; //屏蔽外部的new private SingletonClass() &#123; &#125; //提供一个全局访问点 public synchronized static SingletonClass getInstance() &#123; //....其它代码 if(ONLY==null) &#123; ONLY = new SingletonClass(); &#125; //....其它代码 return ONLY; &#125; public void f() &#123; System.out.println("单例模式。。。。。。。。。。懒汉式"); &#125;&#125;测试类:123456789101112131415161718package 懒汉式;public class Main &#123; public static void main(String[] args) &#123; //SingletonClass a = new SingletonClass(); //a.f(); //SingletonClass a = SingletonClass.ONLY; //用户只能通过静态方法获取实例 SingletonClass a = SingletonClass.getInstance(); SingletonClass b = SingletonClass.getInstance(); System.out.println(a==b); a.f(); &#125;&#125;三、双重验证式懒汉式-延迟加载-线程安全-同步情况下效率高-现实复杂双重验证式懒汉式核心代码：12345678910111213141516171819202122232425262728293031package 双重验证式懒汉式;public class SingletonClass &#123; //创建唯一实例 private static SingletonClass ONLY; //屏蔽外部的new private SingletonClass() &#123; &#125; //提供一个全局访问点 public static SingletonClass getInstance() &#123; //....其它代码 if(ONLY==null) &#123; //B线程等待 synchronized (SingletonClass.class) &#123; if(ONLY == null) &#123; ONLY = new SingletonClass(); //A线程创建 &#125; &#125; &#125; //....其它代码 return ONLY; &#125; public void f() &#123; System.out.println("单例模式。。。。。。。。。。"); &#125;&#125;四、类加载方式-延迟加载-线程安全-同步情况下效率高-实现简单-不能防止反序列化类加载方式核心代码：1234567891011121314151617181920212223package 类加载方式;public class SingletonClass &#123; //屏蔽外部的new private SingletonClass() &#123; &#125; //静态内部类，用于持有唯一的SingletonClass的示例 private static class OnlyInstanceHolder&#123; private static final SingletonClass ONLY = new SingletonClass(); &#125; //公开的唯一访问点 public static SingletonClass getInstance() &#123; return OnlyInstanceHolder.ONLY; &#125; public void f() &#123; System.out.println("单例模式。。。。。。。。。。类加载模式"); &#125;&#125;测试类:123456789101112131415161718package 类加载方式;public class Main &#123; public static void main(String[] args) &#123; //SingletonClass a = new SingletonClass(); //a.f(); //SingletonClass a = SingletonClass.ONLY; //用户只能通过静态方法获取实例 SingletonClass a = SingletonClass.getInstance(); SingletonClass b = SingletonClass.getInstance(); System.out.println(a==b); a.f(); &#125;&#125;五、加载模式方式反序列化-延迟加载-线程安全-同步情况下效率高-实现简单类加载模式方式反序列化核心代码：123456789101112131415161718192021222324252627282930313233343536package 类加载模式方式反序列化;import java.io.ObjectStreamException;import java.io.Serializable;public class SingletonClass implements Serializable, Cloneable &#123; //屏蔽外部的new private SingletonClass() &#123; &#125; //静态内部类，用于持有唯一的SingletonClass的示例 private static class OnlyInstanceHolder&#123; private static final SingletonClass ONLY = new SingletonClass(); &#125; //公开的唯一访问点 public static SingletonClass getInstance() &#123; return OnlyInstanceHolder.ONLY; &#125; //自定义反序列化返回对象,保证被序列化也是同一个对象 private Object readResolve() throws ObjectStreamException&#123; return getInstance(); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return getInstance(); &#125; public void f() &#123; System.out.println("单例模式。。。。。。。。。。类加载模式"); &#125;&#125;六、枚举实现-立即加载-线程安全-实现简单-防止反序列化枚举实现核心代码：123456789package 枚举实现;public enum SingletonClass &#123; INSTANCE; public void f() &#123; System.out.println("单例模式。。。。。。。。。。枚举类型"); &#125;&#125;测试类:12345678910111213141516171819202122package 枚举实现;public class Main &#123; public static void main(String[] args) &#123; //SingletonClass a = new SingletonClass(); //a.f(); //SingletonClass a = SingletonClass.ONLY; //用户只能通过静态方法获取实例 //SingletonClass a = SingletonClass.getInstance(); //SingletonClass b = SingletonClass.getInstance(); SingletonClass a = SingletonClass.INSTANCE; SingletonClass b = SingletonClass.INSTANCE; System.out.println(a==b); a.f(); SingletonClass.INSTANCE.f(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2Ff5c535ea.html</url>
    <content type="text"><![CDATA[适配器模式适配器模式概念适配器模式的定义是,Convert the interface of a class into another interface clientsexpect,将某个类的接口转换为客户所需的类型。换句话说，适配器模式解决的问题是，使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以在一起工作、可以进行统一管理。这样解释适配器的概念还是很抽象。下面以不同工种的工作内容不同，实现统一管理为例来解释适配器设计模式。未使用适配器模式举例厨师接口,厨师的任务是烹饪12345package com.learn.worker;public interface ICooker &#123; public String cook();&#125;厨师的实现类,全聚德的厨师123456789101112package com.learn.worker.impl;import com.learn.worker.ICooker;public class QjdCooker implements ICooker &#123; @Override public String cook() &#123; return "烤制美味烤鸭"; &#125;&#125;程序员接口，程序员的任务是编程12345package com.learn.worker;public interface IProgrammer &#123; String programmer();&#125;程序员的实现类，京东程序员123456789101112package com.learn.worker.impl;import com.learn.worker.IProgrammer;public class JdProgrammer implements IProgrammer &#123; @Override public String programmer() &#123; return "编写高效程序"; &#125;&#125;测试类:1234567891011121314151617181920package com.learn.test;import com.learn.worker.ICooker;import com.learn.worker.IProgrammer;import com.learn.worker.impl.JdProgrammer;import com.learn.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; /* * 未使用适配器 */ ICooker qjdCooker = new QjdCooker(); IProgrammer jdProgrammer = new JdProgrammer(); System.out.println(qjdCooker.cook()); System.out.println( jdProgrammer.programmer()); &#125;&#125;使用适配器模式举例厨师接口,厨师的任务是烹饪12345package com.learn.worker;public interface ICooker &#123; public String cook();&#125;厨师的实现类,全聚德的厨师123456789101112package com.learn.worker.impl;import com.learn.worker.ICooker;public class QjdCooker implements ICooker &#123; @Override public String cook() &#123; return "烤制美味烤鸭"; &#125;&#125;程序员接口，程序员的任务是编程12345package com.learn.worker;public interface IProgrammer &#123; String programmer();&#125;程序员的实现类，京东程序员123456789101112package com.learn.worker.impl;import com.learn.worker.IProgrammer;public class JdProgrammer implements IProgrammer &#123; @Override public String programmer() &#123; return "编写高效程序"; &#125;&#125;适配器接口:12345package com.learn.adapters;public interface IWorkerAdapter &#123; String work(Object work);&#125;适配器实现类:123456789101112131415161718192021222324package com.learn.adapters.impl;import com.learn.adapters.IWorkerAdapter;import com.learn.worker.ICooker;import com.learn.worker.IProgrammer;//适配器类public class WorkerAdapterImpl implements IWorkerAdapter &#123; @Override public String work(Object work) &#123; String workContent = ""; //若传来的对象是厨师，则调用其cook()方法 if(work instanceof ICooker) &#123; workContent = ((ICooker)work).cook(); &#125; if(work instanceof IProgrammer) &#123; workContent = ((IProgrammer)work).programmer(); &#125; return workContent; &#125;&#125;测试类:123456789101112131415161718192021222324252627package com.learn.test;import com.learn.adapters.IWorkerAdapter;import com.learn.adapters.impl.WorkerAdapterImpl;import com.learn.worker.ICooker;import com.learn.worker.IProgrammer;import com.learn.worker.impl.JdProgrammer;import com.learn.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; /* * 使用适配器 */ ICooker qjdCooker = new QjdCooker(); IProgrammer jdProgrammer = new JdProgrammer(); Object[] works = &#123;qjdCooker, jdProgrammer&#125;; IWorkerAdapter adapter = new WorkerAdapterImpl(); //循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : works) &#123; String workContent = adapter.work(worker); System.out.println(workContent); &#125; &#125;&#125;适配器模式最终版厨师接口,厨师的任务是烹饪12345package com.learn.worker;public interface ICooker &#123; public String cook();&#125;厨师的实现类,全聚德的厨师123456789101112package com.learn.worker.impl;import com.learn.worker.ICooker;public class QjdCooker implements ICooker &#123; @Override public String cook() &#123; return "烤制美味烤鸭"; &#125;&#125;程序员接口，程序员的任务是编程12345package com.learn.worker;public interface IProgrammer &#123; String programmer();&#125;程序员的实现类，京东程序员123456789101112package com.learn.worker.impl;import com.learn.worker.IProgrammer;public class JdProgrammer implements IProgrammer &#123; @Override public String programmer() &#123; return "编写高效程序"; &#125;&#125;适配器接口类:123456package com.learn.adapters;public interface IWorkerAdapter &#123; String work(Object worker); Boolean supports(Object worker);&#125;适配器实现类CookerAdapter.java123456789101112131415161718package com.learn.adapters.impl;import com.learn.adapters.IWorkerAdapter;import com.learn.worker.ICooker;public class CookerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((ICooker)worker).cook(); &#125; @Override public Boolean supports(Object worker) &#123; return (worker instanceof ICooker); &#125;&#125;适配器实现类ProgrammerAdapter.java12345678910111213141516171819package com.learn.adapters.impl;import com.learn.adapters.IWorkerAdapter;import com.learn.worker.IProgrammer;public class ProgrammerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((IProgrammer)worker).programmer(); &#125; @Override public Boolean supports(Object worker) &#123; return (worker instanceof IProgrammer); &#125;&#125;测试类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.learn.test;import java.util.ArrayList;import java.util.List;import com.learn.adapters.IWorkerAdapter;import com.learn.adapters.impl.CookerAdapter;import com.learn.adapters.impl.ProgrammerAdapter;import com.learn.worker.ICooker;import com.learn.worker.IProgrammer;import com.learn.worker.impl.JdProgrammer;import com.learn.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; /* * 使用适配器 */ ICooker qjdCooker = new QjdCooker(); IProgrammer jdProgrammer = new JdProgrammer(); Object[] works = &#123;qjdCooker, jdProgrammer&#125;; //循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : works) &#123; IWorkerAdapter adapter = getAdapter(worker); System.out.println(adapter.work(worker)); &#125; &#125; /** * * @Title: getAdapter * @Description: 根据worker获取相应的适配器模式 * @param @param worker * @param @return * @return 返回类型为:IWorkerAdapter * @throws */ private static IWorkerAdapter getAdapter(Object worker) &#123; List&lt;IWorkerAdapter&gt; adapters = getAllAdapters(); for (IWorkerAdapter adapter : adapters) &#123; if(adapter.supports(worker)) &#123; return adapter; &#125; &#125; return null; &#125; /** * * @Title: getAllAdapters * @Description: 获取所有的适配器 * @param @return * @return 返回类型为:List&lt;IWorkerAdapter&gt; * @throws */ private static List&lt;IWorkerAdapter&gt; getAllAdapters() &#123; List&lt;IWorkerAdapter&gt; adapters = new ArrayList&lt;&gt;(); adapters.add(new CookerAdapter()); adapters.add(new ProgrammerAdapter()); return adapters; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openwrt路由器搭建svn服务器]]></title>
    <url>%2FSVN%2F8f422d7f.html</url>
    <content type="text"><![CDATA[GL-MT300A OpenWrt路由器安装svn服务入手一款Gl-MT300A便携式迷你路由器，基于openWrt系统，想在上面搭建一个svn，测试方便以后添加硬盘或者内存卡使用，将搭建步骤记录如下，我将其分为以下七步：1 . 使用SecureCrt连接到路由器。2 . 安装subversion-server12opkg update opkg install subversion-server3 . 安装完毕，使用svnserve –version查看版本，判断是否安装成功，然后创建第一个repository12mkdir -p /mnt/SVNRepositories/test/svnadmin create /mnt/SVNRepositories/test/4 . 修改配置文件1234567891011121314151617181920212223242526vim /mnt/SVNRepositories/test/conf/svnserve.conf内容修改为如下:### This file controls the configuration of the svnserve daemon, if you### use it to allow access to this repository. (If you only allow### access through http: and/or file: URLs, then this file is### irrelevant.)### Visit http://subversion.apache.org/ for more information.[general]### These options control access to the repository for unauthenticated### and authenticated users. Valid values are "write", "read",### and "none". The sample settings below are the defaults.anon-access = readauth-access = write### The password-db option controls the location of the password### database file. Unless you specify a path starting with a /,### the file's location is relative to the directory containing### this configuration file.### If SASL is enabled (see below), this file will NOT be used.### Uncomment the line below to use the default password file.password-db = passwd### The authz-db option controls the location of the authorization### rules for path-based access control. Unless you specify a path### starting with a /, the file's location is relative to the the1234567891011121314151617181920修改authz为如下:[aliases] # joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average [groups] # harry_and_sally = harry,sally # harry_sally_and_joe = harry,sally,&amp;joe # [/foo/bar] # harry = rw # &amp;joe = r # * = [/] ### user config test = rw caifl = rw # [repository:/baz/fuz] # @harry_and_sally = rw # * = r12345678910111213修改passwd如下:### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry = harryssecret# sally = sallyssecret### user password configtest = testcaifl = 19931129cfl5 . 进入目录/etc/config目录,修改文件subversion，配置本地仓库地址：vim /etc/confi/subversion1234567配置如下:root@GL-MT300A:/etc/config# vim subversion config subversion ### 本地仓库地址配置 option path '/mnt/SVNRepositories/' option port '3690'6 . 启动或者停止svn服务:12启动:/etc/init.d/subversion start停止:/etc/init.d/subversion stop7 . 通过TortoisSVN检出，路径地址:svn://192.168.0.1/test,输入配置的用户名和密码，即test检出成功。教程至此结束，特此谨记。]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射机制]]></title>
    <url>%2FJava%2F3ecb78ee.html</url>
    <content type="text"><![CDATA[根据class获取java对象的三种方式123456789101112// 第一种方式Class c1 = Class.forName("com.caifenglin.reflect.Employee");// 第二种方式// java中每个类型都class属性Class c2 = Employee.class;// 第三种方式// java语言中任何一个java对象都有getClass方法Employee e = new Employee();// c3是运行时类(e的运行时类是Emplyoee)Class c3 = e.getClass();注意:在使用.class反射获取对象时不会执行对象中的静态代码块，如下:12345678910111213141516public class ReflelctTest02 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 将A.class文件装载到JVM中的过程,会执行静态语句块 // Class.forName("com.caifenglin.reflect.A"); // 不会执行静态语句块 Class c = com.caifenglin.reflect.A.class; &#125;&#125;class A &#123; static &#123; System.out.println("A········"); &#125;&#125;获取Class类型的对象之后，可以创建该类的对象12345678910111213141516171819public class ReflectTest03 &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.caifenglin.reflect.Employee"); // 创建此Class对象所表示的一个新实例,调用了Emplyoee的无参构造方法 Object o = c.newInstance(); System.out.println(o); // com.caifenglin.reflect.Employee@7852e922 Class c1 = Class.forName("java.util.Date"); Object o1 = c1.newInstance(); if(o1 instanceof Date) &#123; Date d = (Date)o1; System.out.println(new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒").format(d)); &#125; &#125;&#125;java.lang.reflect.Field; 类中的属性反编译所有类中的属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * java.lang.reflect.Field; 类中的属性 * 反编译所有类中的属性 * @author caifenglin * */public class ReflectTest04 &#123; public static void main(String[] args) throws Exception &#123; // 获取整个类 Class c = Class.forName("com.caifenglin.reflect.Student"); // 获取属性Field // 获取所有public修饰的属性 Field[] fs = c.getFields(); System.out.println(fs.length); System.out.println(fs[0]); System.out.println("======================="); Field[] dfs = c.getDeclaredFields(); /*for (Field field : dfs) &#123; int i = field.getModifiers(); String modifiers = Modifier.toString(i); System.out.println(modifiers); Class type = field.getType(); //System.out.println("type名称"+type.getName()); System.out.println(type.getSimpleName()); System.out.println(field.getName()); &#125;*/ StringBuffer sb = new StringBuffer(); sb.append(Modifier.toString(c.getModifiers()) + " class " + c.getSimpleName() + "&#123;"); for (Field field : dfs) &#123; sb.append("\t"); sb.append(Modifier.toString(field.getModifiers()) + " "); sb.append(field.getType().getSimpleName() + " "); sb.append(field.getName() + ";\n"); &#125; sb.append("&#125;"); System.out.println(sb); &#125;&#125;java.lang.reflect.Filed; 获取某个指定的属性12345678910111213141516171819202122public class ReflectTest05 &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.caifenglin.reflect.Student"); // 获取所有属性 //Field[] fs = c.getDeclaredFields(); // 获取某个特定属性，获取name属性 Field df = c.getDeclaredField("name"); Object o = c.newInstance(); // 打破封装 df.setAccessible(true);// 使用反射机制可以打破封装机制，使java对象的属性不安全 df.set(o, "caifenglin"); System.out.println(df.get(o)); &#125;&#125;java.lang.reflect.Method;获取类中的方法反编译所有类中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ReflectMethod01 &#123; public static void main(String[] args) throws Exception &#123; // 获取类 //Class c = Class.forName("com.caifenglin.reflect.Student"); Class c = Class.forName("java.lang.String"); // 获取所有方法 /*Method[] methods = c.getDeclaredMethods(); for (Method method : methods) &#123; // 修饰符 System.out.println(Modifier.toString(method.getModifiers())); // 方法的返回值类型 Class returnType = method.getReturnType(); System.out.println(returnType.getSimpleName()); // 方法名 System.out.println(method.getName()); // 方法的形式参数 Class[] paramterTypes = method.getParameterTypes(); for (Class paramterType : paramterTypes) &#123; System.out.println(paramterType.getSimpleName()); &#125; &#125;*/ // 反编译 StringBuffer sb = new StringBuffer(); sb.append(Modifier.toString(c.getModifiers()) + " class "); sb.append(c.getSimpleName() + "&#123;\n"); // 获取所有方法 Method[] methods = c.getDeclaredMethods(); for (Method m : methods) &#123; sb.append("\t"); sb.append(Modifier.toString(m.getModifiers()) + " "); sb.append(m.getReturnType().getSimpleName()+ " "); sb.append(m.getName()+"("); // 形参 Class[] parameterTypes = m.getParameterTypes(); for(int i = 0; i &lt; parameterTypes.length; i++) &#123; Class parameterType = parameterTypes[i]; if(i == parameterTypes.length - 1) &#123; sb.append(parameterType.getSimpleName()); &#125; else &#123; sb.append(parameterType.getSimpleName() + ", "); &#125; &#125; sb.append(")&#123;&#125;\n"); &#125; sb.append("&#125;"); System.out.println(sb); &#125;&#125;获取某个特定的方法，通过反射机制执行1234567891011121314151617181920212223242526/** * 获取某个特定的方法，通过反射机制执行 * 以前:Student student = new Student(); * boolean isSuccess = student.login("admin","123"); * * @author caifenglin * */public class ReflectMethod02 &#123; public static void main(String[] args) throws Exception &#123; // 1.获取类 Class c = Class.forName("com.caifenglin.reflect.Student"); // 获取某个特定的方法 // 通过:方法名+形参列表 Method m = c.getDeclaredMethod("login", String.class, String.class); // 通过反射机制执行login方法 Object o = c.newInstance(); // 调用o对象的m方法，传递"admin", "123"参数，方法的执行结果是retValue Object retValue = m.invoke(o, "admin", "123"); System.out.println(retValue); &#125;&#125;java.lang.reflect.Constructor;获取类中的构造方法反编译所有类中的所有构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ReflectConstruct01 &#123; public static void main(String[] args) throws Exception &#123; // 1.获取类 Class c = Class.forName("java.lang.String"); // 2.获取所有的构造 Constructor[] cs = c.getDeclaredConstructors(); /* for (Constructor constructor : cs) &#123; // 获取修饰符 System.out.println(Modifier.toString(constructor.getModifiers())); // 获取构造方法名 System.out.println(c.getName()); // 构造方法的形式参数列表 Class[] parameterTypes = constructor.getParameterTypes(); for (Class parameterType : parameterTypes) &#123; System.out.println(parameterType.getSimpleName()); &#125; &#125;*/ // 反编译 StringBuffer sb = new StringBuffer(); sb.append(Modifier.toString(c.getModifiers()) + " class " + c.getSimpleName() + "&#123;\n"); // 构造方法 for (Constructor constructor : cs) &#123; sb.append("\t"); sb.append(Modifier.toString(constructor.getModifiers()) + " "); sb.append(c.getSimpleName() + "("); // 形参 Class[] parameterTypes = constructor.getParameterTypes(); for(int i = 0; i &lt; parameterTypes.length; i++) &#123; Class parameterType = parameterTypes[i]; if(i == parameterTypes.length - 1) &#123; sb.append(parameterType.getSimpleName()); &#125; else &#123; sb.append(parameterType.getSimpleName() + ", "); &#125; &#125; sb.append(")&#125;\n"); &#125; sb.append("&#125;"); System.out.println(sb); &#125;&#125;java.lang.reflect.Constructor;获取某个特定的构造方法1234567891011121314151617public class ReflectConstruct02 &#123; public static void main(String[] args) throws Exception &#123; // 1.获取类 Class c = Class.forName("com.caifenglin.reflect.Customer"); // 2.获取特定的构造方法 Constructor dc = c.getDeclaredConstructor(String.class, int.class); // 3.创建对象 Object o = dc.newInstance("李四", 24); System.out.println(o); &#125;&#125;以上反射中的实体类：员工类123456789101112131415161718192021package com.caifenglin.reflect;public class Employee &#123; // Field private String name; // Constructor public Employee() &#123; System.out.println("Employee无参构造方法执行"); &#125; public Employee(String name) &#123; this.name = name; &#125; // method public void work() &#123; System.out.print("在工作!"); &#125;&#125;student类123456789101112131415161718public class Student &#123; // Field private String name; public int age; protected String address; boolean sex; public boolean login(String username, String password) &#123; if("admin".equals(username) &amp;&amp; "123".equals(password)) &#123; return true; &#125; return false; &#125; public void m1() &#123; System.out.println("hello reflect"); &#125;&#125;可变长参数举例123456789101112131415161718192021222324/** * 关于Java中的可变长参数 * @author caifenglin * */public class Test01 &#123; // 可变长参数只能出现一次，并且只能出现在最后的位置 public static void m1(int... a) &#123; System.out.println("Test"); &#125; public static void m1(int a) &#123; System.out.println(1); &#125; // 如果有精确匹配的方法，则调用该精确方法；可变参数可以看做数组 public static void main(String[] args) &#123; m1(); m1(2); m1(1,2); m1(1,2,3,4,5); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F2aa1ddf5.html</url>
    <content type="text"><![CDATA[模板方法设计模式详解模板方法设计模式模板方法设计模式的定义是:定义一个操作中某种算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类在不改变一个算法结构的前提下，对某些步骤实现个性化定义。模板方法程序构成在模板方法设计模式中，存在一个父类。其中包含两类方法:模板方法与步骤方法。模板方法:即实现某种算法的方法步骤。而这些步骤都是调用的步骤方法完成的。步骤方法:即完成模板方法的每个阶段性方法。每个步骤方法完成某一特定的、完成总算法的一部分功能。步骤方法有三种类型:抽象方法、最终方法与钩子方法。抽象方法:是要求子类必须实现的方法，是完成模板方法的算法步骤中必须由子类完成的个性化定义。最终方法:是子类不能重写的方法，是完成模板方法的算法步骤中必须由子类完成的个性化定义。钩子方法:是父类给出了默认实现，但子类也可以重写的方法。代码如下:123456789101112131415161718192021222324package com.learn.service;public abstract class Shopping &#123; public void buyGoods()&#123; userLogin(); buy(); pay(); &#125; //子类不能重写的方法 public final void userLogin() &#123; System.out.println("用户登录"); &#125; //子类必须实现 public abstract void buy(); public void pay() &#123; System.out.println("使用银联卡支付"); &#125; &#125;123456789101112131415package com.learn.service;public class ClothesShop extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买七匹狼男装"); &#125; @Override public void pay() &#123; System.out.println("使用支付宝付款"); &#125;&#125;1234567891011package com.learn.service;public class ShoesShopping extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买红蜻蜓皮鞋"); &#125;&#125;测试类:123456789101112131415package com.learn.test;import com.learn.service.ClothesShop;import com.learn.service.ShoesShopping;import com.learn.service.Shopping;public class MyTest &#123; public static void main(String[] args) &#123; Shopping shoesShopping = new ShoesShopping(); shoesShopping.buyGoods(); Shopping clothesShopping = new ClothesShop(); clothesShopping.buyGoods(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL对时间常用操作]]></title>
    <url>%2FMySQL%2Ff7ceb3c1.html</url>
    <content type="text"><![CDATA[mysql 查询当天、本周，本月，上一个月的数据今天select * from 表名 where to_days(时间字段名) = to_days(now());昨天SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1近7天SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名)近30天SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名)本月SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ )上一月SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , ‘%Y%m’ ) , date_format( 时间字段名, ‘%Y%m’ ) ) =1查询本季度数据select * from ht_invoice_information where QUARTER(create_date)=QUARTER(now());查询上季度数据select * from ht_invoice_information where QUARTER(create_date)=QUARTER(DATE_SUB(now(),interval 1 QUARTER));查询本年数据select * from ht_invoice_information where YEAR(create_date)=YEAR(NOW());查询上年数据select * from ht_invoice_information where year(create_date)=year(date_sub(now(),interval 1 year));查询当前这周的数据SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,’%Y-%m-%d’)) = YEARWEEK(now());查询上周的数据SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,’%Y-%m-%d’)) = YEARWEEK(now())-1;查询上个月的数据select name,submittime from enterprise where date_format(submittime,’%Y-%m’)=date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),’%Y-%m’)select * from user where DATE_FORMAT(pudate,’%Y%m’) = DATE_FORMAT(CURDATE(),’%Y%m’) ;select * from user where WEEKOFYEAR(FROM_UNIXTIME(pudate,’%y-%m-%d’)) = WEEKOFYEAR(now())select * from user where MONTH(FROM_UNIXTIME(pudate,’%y-%m-%d’)) = MONTH(now())select * from user where YEAR(FROM_UNIXTIME(pudate,’%y-%m-%d’)) = YEAR(now()) and MONTH(FROM_UNIXTIME(pudate,’%y-%m-%d’)) = MONTH(now())select * from user where pudate between 上月最后一天 and 下月第一天查询当前月份的数据select name,submittime from enterprise where date_format(submittime,’%Y-%m’)=date_format(now(),’%Y-%m’)查询距离当前现在6个月的数据select name,submittime from enterprise where submittime between date_sub(now(),interval 6 month) and now();查询当前年月日，时分秒select now();查询当前年select year(now());查询当前月份select month(now());查询当前日select day(now());查询当前时select Hour(now());如下:set @dt = ‘2008-09-10 07:15:30.123456’;select date(@dt); – 2008-09-10select time(@dt); – 07:15:30.123456select year(@dt); – 2008select quarter(@dt); – 3select month(@dt); – 9select week(@dt); – 36select day(@dt); – 10select hour(@dt); – 7select minute(@dt); – 15select second(@dt); – 30select microsecond(@dt); – 123456MySQL dayof… 函数：dayofweek(), dayofmonth(), dayofyear()分别返回日期参数，在一周、一月、一年中的位置。set @dt = ‘2008-08-08’;select dayofweek(@dt); – 6select dayofmonth(@dt); – 8select dayofyear(@dt); – 221MySQL week… 函数：week(), weekofyear(), dayofweek(), weekday(), yearweek()set @dt = ‘2008-08-08’;select week(@dt); – 31select week(@dt,3); – 32select weekofyear(@dt); – 32select dayofweek(@dt); – 6select weekday(@dt); – 4select yearweek(@dt); – 200831MySQL 返回星期和月份名称函数：dayname(), monthname()set @dt = ‘2008-08-08’;select dayname(@dt); – Fridayselect monthname(@dt); – AugustMySQL last_day() 函数：返回月份中的最后一天。select last_day(‘2008-02-01’); – 2008-02-29select last_day(‘2008-08-08’); – 2008-08-31MySQL 日期时间计算函数MySQL 为日期增加一个时间间隔：date_add()set @dt = now();select date_add(@dt, interval 1 day); – add 1 dayselect date_add(@dt, interval 1 hour); – add 1 hourselect date_add(@dt, interval 1 minute); – …select date_add(@dt, interval 1 second);select date_add(@dt, interval 1 microsecond);select date_add(@dt, interval 1 week);select date_add(@dt, interval 1 month);select date_add(@dt, interval 1 quarter);select date_add(@dt, interval 1 year);select date_add(@dt, interval -1 day); – sub 1 dayMySQL查询一个月天数select (curdate()-interval day(curdate()) day) + interval s day as dtfrom (select 1 as sunion allselect 2union allselect 3union allselect 4union allselect 5union allselect 6union allselect 7union allselect 8union allselect 9union allselect 10union allselect 11union allselect 12union allselect 13union allselect 14union allselect 15union allselect 16union allselect 17union allselect 18union allselect 19union allselect 20union allselect 21union allselect 22union allselect 23union allselect 24union allselect 25union allselect 26union allselect 27union allselect 28union allselect 29union allselect 30union allselect 31) mwhere s&lt;=day(LAST_DAY(CURDATE()));MySQL查询当月天数select m.s as dayfrom (select 1 as sunion allselect 2union allselect 3union allselect 4union allselect 5union allselect 6union allselect 7union allselect 8union allselect 9union allselect 10union allselect 11union allselect 12union allselect 13union allselect 14union allselect 15union allselect 16union allselect 17union allselect 18union allselect 19union allselect 20union allselect 21union allselect 22union allselect 23union allselect 24union allselect 25union allselect 26union allselect 27union allselect 28union allselect 29union allselect 30union allselect 31) mwhere s&lt;=day(LAST_DAY(CURDATE()));一些用法如下:mysql&gt; select DATE_FORMAT(CURDATE(), ‘%Y%m’);+——————————–+| DATE_FORMAT(CURDATE(), ‘%Y%m’) |+——————————–+| 201803 |+——————————–+1 row in set (0.00 sec)mysql&gt; select DATE_SUB(‘2017-04-01’,INTERVAL 1 MONTH)-&gt; ;+—————————————–+| DATE_SUB(‘2017-04-01’,INTERVAL 1 MONTH) |+—————————————–+| 2017-03-01 |+—————————————–+1 row in set (0.05 sec)mysql&gt; select DATE_SUB(‘2017-04-01’,INTERVAL 1 YEAR);+—————————————-+| DATE_SUB(‘2017-04-01’,INTERVAL 1 YEAR) |+—————————————-+| 2016-04-01 |+—————————————-+1 row in set (0.00 sec)mysql&gt; select DATE_SUB(NOW(),INTERVAL 1 YEAR);+———————————+| DATE_SUB(NOW(),INTERVAL 1 YEAR) |+———————————+| 2017-03-27 09:20:22 |+———————————+1 row in set (0.00 sec)mysql&gt; select DATE_SUB(NOW(),INTERVAL 1 YEAR);+———————————+| DATE_SUB(NOW(),INTERVAL 1 YEAR) |+———————————+| 2017-03-27 09:21:42 |+———————————+1 row in set (0.00 sec)mysql&gt;mysql&gt; select ( DATE_FORMAT(now(), ‘%Y%m’)-1);+———————————+| ( DATE_FORMAT(now(), ‘%Y%m’)-1) |+———————————+| 201802 |+———————————+1 row in set (0.07 sec)mysql&gt; select ( DATE_FORMAT(now(), ‘%m’)-1);+——————————-+| ( DATE_FORMAT(now(), ‘%m’)-1) |+——————————-+| 2 |+——————————-+1 row in set (0.00 sec)mysql&gt; select DATE_FORMAT(CURDATE(), ‘%Y%m’);+——————————–+| DATE_FORMAT(CURDATE(), ‘%Y%m’) |+——————————–+| 201803 |+——————————–+1 row in set (0.08 sec)mysql&gt; select YEAR(DATE_SUB(NOW(),INTERVAL 1 YEAR));+—————————————+| YEAR(DATE_SUB(NOW(),INTERVAL 1 YEAR)) |+—————————————+| 2017 |+—————————————+1 row in set (0.06 sec)mysql&gt; select DATE_FORMAT(now(), ‘%Y%m’);+—————————-+| DATE_FORMAT(now(), ‘%Y%m’) |+—————————-+| 201803 |+—————————-+1 row in set (0.27 sec)mysql&gt; select DATE_FORMAT(now(), ‘%m’);+————————–+| DATE_FORMAT(now(), ‘%m’) |+————————–+| 03 |+————————–+1 row in set (0.00 sec)以下展示两个例子，按月统计和按日统计:1234567891011if("year".equals(type)) &#123; // 年走势，按月查 unit = "月"; title = TimeUtil.getCurrentYear() +"问题缺陷走势"; sql = "select distinct a. month as name, ifnull(b.count, 0) as count from ( select 1 as month union select 2 as month union select 3 as month union select 4 as month union select 5 as month union select 6 as month union select 7 as month union select 8 as month union select 9 as month union select 10 as month union select 11 as month union select 12 as month ) as a left join ( select month (fd_jlsj) as month, count(pk_qxyhjl) as count from t_sb_qxyhjl where year (fd_jlsj) = year (now()) and pub_jlzt &lt;&gt; '草拟' group by month (fd_jlsj)) as b on a. month = b. month"; &#125; else if("month".equals(type)) &#123; // 月走势，按日查 unit = "日"; title = TimeUtil.getCurrentYearMonth() +"问题缺陷走势"; sql = "select distinct a. day as name, ifnull(b.count, 0) as count from ( select m.s as day from ( select 1 as s union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 12 union all select 13 union all select 14 union all select 15 union all select 16 union all select 17 union all select 18 union all select 19 union all select 20 union all select 21 union all select 22 union all select 23 union all select 24 union all select 25 union all select 26 union all select 27 union all select 28 union all select 29 union all select 30 union all select 31 ) m where s &lt;= day (last_day(curdate()))) as a left join ( select day (fd_jlsj) as day, count(pk_qxyhjl) count from t_sb_qxyhjl where date_format(now(), '%Y-%m') = date_format(fd_jlsj, '%Y-%m') and pub_jlzt &lt;&gt; '草拟' group by day (fd_jlsj)) as b on a. day = b. day"; &#125;MySQL修改字段：t_table 表示:表名t_filed 表示:字段添加字段alter table t_table add column t_filed int(11) DEFAULT NULL COMMENT ‘是否是名家:0:否，1是’;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库介绍与分类]]></title>
    <url>%2FMySQL%2Fe95cfa56.html</url>
    <content type="text"><![CDATA[1.1 数据库介绍1.1.1 什么是数据库？简单的说，数据库(英文DataBase)就是一个存放数据的仓库，这个仓库是按照一定的数据结构(数据结构是指数据的组织形式或数据之间的联系)来组织、存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。更简单的形象理解，数据库和我们生活中存放杂物的储物间仓库性质一样，区别只是存放的东西不同。杂物间存放实体的物件，而数据库里存储的是数据，这样我们就对数据库有一个初步的了解。数据库诞生于距现在大概六十多年前，随着信息技术的发展和人类社会的不断进步，特别是2000年以后，数据不仅仅是存储和管理数据了，而转变成用户所需要的各种数据管理方式。数据库有很多种类和功能，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库都在各个方面得到了广泛的应用。1.2 数据库的种类按照早期的数据库理论，比较流行的数据库模型有三种，分别为层次式数据库、网路式数据库和关系型数据库。而在当今的互联网中，最常用的数据库模型主要是两种，即关系型数据库和非关系型数据，我们不是写教科书，更不是研究数据库理论，因此，我们主要讲解关系数据库和非关系数据库这两类最重要的也是目前实际使用中最多的数据种类。1.2.1 关系型数据库介绍(1)关系型数据库由来虽然网状数据库和层次数据库已经很好地解决了数据的集中和共享问题，但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取是，仍然需要明确数据的存储结构，支出存取路劲。而关系数据库就可以较好地解决这些问题。(2)关系数据库介绍关系数据库模型是吧复杂的数据结构归结为简单的二元关系(即二维表格形式)。例如老男孩教育某一期的学生关系就是一个二元关系。在关系数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据的管理。关系数据库诞生距今已有40多年了，从理论产生发展到现实产品，例如：大家最常见的MySQL和Oracle数据库，Oracle在数据库领域里上升到了霸主地位，形成每年高达数百亿美元的庞大产业市场，而MySQL也是不容忽视的数据库，以至于被Oracle重金收购了。(3)关系型数据库表格之间的关系举例1.2.2 非关系型数据库介绍1.2.2.1 非关系型数据库诞生背景非关系型数据库也被称为NOSQL数据库，请读者注意，NOSQL的本意是“Not Only SQL”，指的是非关系型数据库，而不是“NO SQL”的意思(没有SQL语句?)，因此，NoSQL的产生并不是要彻底地否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NoSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是对于规模日益扩大的海量数据，超大的规模和高并发的微博、微信、SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如:传统的关系数据库IO瓶颈、性能瓶颈都难以有效突破，于是开始出现了大批针对特定场景，以高性能和使用便利为目的功能特异化的数据库产品，NoSQL(非关系型)类的数据库就是在这样的情景中诞生并得到了非常迅速的发展。NOSQL是非关系型数据库的广义定义。它打破了长久以来关系型数据与ACID理论大一统的局面。NoSQL(非关系型)类的数据库就是在这样的情景中诞生并得到了非常迅速的发展。NoSQL是非关系型数据库广义定义。它打破了长久以来关系数据库与ACID理论大一统的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取中具备关系数据库无法比拟的性能优势。该术语（NoSQL）在2009年初得到了广泛认同。当今的应用日系结构需要数据库存储在横向伸缩性上能够满足需求。而NoSQL存储就是为了实现这个需求而诞生的。Google的BigTable与Amazon的Dynamo是非常成功的商业NoSQL实现。一些开源的NoSQL体系，如Facebook的Cassandre，Apache的HBase，也得到了广泛认同，Rediso，mongodb也逐渐的越来越受到各类大中小型公司的欢迎和追捧。1.2.2.1 非关系型数据库的种类(1)键值(Key-Value)存储数据库键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据，因为使用key主键访问，所有会获得很高的性能及扩展性键值(Key-Value)数据库主要是使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/Value模型对于IT系统来说的优势在于简单、易部署、高并发。典型产品：Memcached、Redis、MemcacheDB、Berkeley DB(2)列存储(Column-oriented)数据库列存储数据库将数据存储在列族(column family)中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是他们的特点是指向了多个列。这些列是由列家族来安排的。典型产品: Cassandra, HBase(3)面向文档(Documnent-Oriented) 数据库文档数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看做是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。面向文档数据库会将数据以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。典型产品: MongoDB、 CouchDB(4)图形（Graph）数据库图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，SteveJobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到对个服务器上。NoSQL数据库没有标准的查询语言(SQL),因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。典型产品:Neo4J、 InfoGrid1.3 常用关系型数据库产品介绍1.3.1 Oracle数据库Oracle前身叫SDL，由Larry Ellison和另两个编程人员在1977年创办，他们开发了自己的拳头产品，在市场上大量销售，1979年，Oracle公司引入了第一个商用SQL关系数据库管理系统。Oracle公司是最早开发关系数据库的厂商之一，其产品支持最广泛的操作系统平台。目前Oracle关系数据库产品的市场占有率数一数二。Oracle公司是目前全球最大的数据库软件公司，也是近年业务增长极为迅速的软件提供商与服务商。2007年7月12日，甲骨文公司在美国纽约宣布推出数据库Oracle 11g，这是Oracle数据库的最新版本。Oralce介绍说，Oracle 11g有400多项功能，经过了1500万个小时的测试，开发工作量达到了3.6万人/月。Oracle11g在安全，XML DB，备份等方面得到了很大提升。主要应用范围: 传统大企业，大公司，政府， 金融， 证券等等。版本升级: Oracle8i, Oracle9i, Oracle10g, Oracle11g, Oracle12c1.3.2 MySQL数据库MySQL数据库是一个中小型关系型数据库管理系统，软件开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购，后Sun公司又被Oracle公司收购。目前MySQL被广泛地应用在Internet上的大中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多大中小型网站为了降低网站总体拥有成本而选择了MySQL。作为网站数据库，甚至国内知名的淘宝网也选择弃用Oracle而更换为更开放的MySQL。MySQL数据库主要应用范围:互联网领域，大中小型网站，游戏公司，电商平台等等。1.3.3 MariaDB数据库MariaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。开发这个MariaDB数据库分支的可能原因之一是:甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。开发MariaDB数据库的目的是完全兼容MySQL数据库，包括API和命令行，使之能轻松的成为MySQL的代替品。在存储引擎方面，使用XtraDB(英语: XtraDB)来代替MySQL的InnoDB。MariaDB由MySQL的创始人Michael Widenius(英语:Michael Widenius)主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB数据库的名称来自于MySQL的创始人Michael Widenius的女儿Maria的名字。MariaDB数据库直到5.5版本，均依照MySQL的版本发行。因此，使用MariaDB5.5的人会从MySQL5.5中了解到MariaDB的所有功能。1.3.4 SQL Server数据库Microsoft SQL Server是微软公司开发的大型关系数据库系统。SQL Server的功能比较全面，效率高，可以作为中型企业或单位的数据库平台。SQL Server可以与Windows操作系统紧密集成，不论是应用程序开发速度还是系统事物处理运行速度，都能得到较大提升。对于在Windows平台上开发的各种企业级信息管理系统来说，不论是C/S(客户机/服务器)架构还是B/S(浏览器/服务器)架构，SQL Server都是一个很好的选择。SQL Server的缺点是只能在WIndows系统下运行。1987年，微软和IBM合作开发完成OS/2，IBM在其销售的OS/2 ExtendedEdition系统中绑定了OS/2 Database Manager，而微软产品线中尚缺少数据库产品。为此，微软将目光投向了Sybase，同Sybase签订了合作协议，使用Sybase的技术开发基于OS/2平台的关系型数据库。1989年，微软发布了SQL Server1.0版本。 Microsoft在于Sybase分道扬镳后，随后在其6.05和7.0版本中重写了核心数据库系统，如今SQL Server2008即将到来。主要应用范围:部分企业电商(央视购物),使用windows服务器平台的企业。1.3.5 Access数据库美国Microsoft公司与1994年推出的微机数据库管理系统。它具有界面友好、易学易用、开发简单、接口灵活等特点，是典型的新一代桌面关系数据库管理系统。它结合了Microsoft Jet Database Engine和图形用户界面两项特点，是Microsoft Office的成员之一。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2Fd989c0cb.html</url>
    <content type="text"><![CDATA[静态代理模式静态代理模式实现service接口代码:123456package com.learn.service;public interface ISomeServcie &#123; String doFirst(); void doSecond();&#125;service实现类:1234567891011121314151617package com.learn.service;public class SomeServiceImpl implements ISomeServcie &#123; //目标方法 @Override public String doFirst() &#123; System.out.println("执行doFirst()方法"); return "abcde"; &#125; @Override public void doSecond() &#123; System.out.println("执行doSecond()方法"); &#125;&#125;静态代理类:12345678910111213141516171819202122232425262728package com.learn.proxy;import com.learn.service.ISomeServcie;import com.learn.service.SomeServiceImpl;//代理类public class SomeServiceProxy implements ISomeServcie &#123; private ISomeServcie target; public SomeServiceProxy() &#123; target = new SomeServiceImpl(); &#125; @Override public String doFirst() &#123; String result = target.doFirst(); return result.toUpperCase(); &#125; @Override public void doSecond() &#123; target.doSecond(); &#125; &#125;测试类:12345678910111213141516package com.learn.test;import com.learn.proxy.SomeServiceProxy;import com.learn.service.ISomeServcie;import com.learn.service.SomeServiceImpl;public class MyTest &#123; public static void main(String[] agrs) &#123; ISomeServcie servcie = new SomeServiceProxy(); String result = servcie.doFirst(); System.out.println(result); servcie.doSecond(); &#125;&#125;结果:在不修改源代码的情况下增强业务实现，实现doFirst()中首字母大写。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2Fdc7fb504.html</url>
    <content type="text"><![CDATA[动态代理模式详解JDK实现动态代理模式service接口代码实现:123456package com.learn.service;public interface ISomeServcie &#123; String doFirst(); void doSecond();&#125;services实现类:1234567891011121314151617package com.learn.service;public class SomeServiceImpl implements ISomeServcie &#123; //目标方法 @Override public String doFirst() &#123; System.out.println("执行doFirst()方法"); return "abcde"; &#125; @Override public void doSecond() &#123; System.out.println("执行doSecond()方法"); &#125;&#125;测试类:12345678910111213141516171819202122232425262728293031323334353637383940414243package com.learn.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import com.learn.service.ISomeServcie;import com.learn.service.SomeServiceImpl;public class MyTest &#123; public static void main(String[] agrs) &#123; final ISomeServcie target = new SomeServiceImpl(); //使用JDK的Proxy动态代理，要求目标类必须实现接口 //因为其底层的执行原理，与静态代理的相同 ISomeServcie servcie = (ISomeServcie) Proxy.newProxyInstance( //目标类的类加载器 target.getClass().getClassLoader(), //目标类所实现的所有接口 target.getClass().getInterfaces(), //匿名内部类 new InvocationHandler() &#123; //proxy 代理对象本身 //method 目标方法 //args 目标方法的参数列表 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //调用目标方法 Object result = method.invoke(target, args); if (result != null &amp;&amp; result != "") &#123; result = ((String) result).toUpperCase(); &#125; return result; &#125; &#125;); String result = servcie.doFirst(); System.out.println(result); servcie.doSecond(); &#125;&#125;CGLB动态代理需要导入cglib-full.jar，并添加到build path。services类:123456789101112131415package com.learn.service;public class SomeService &#123; //目标方法 public String doFirst() &#123; System.out.println("执行doFirst()方法"); return "abcde"; &#125; public void doSecond() &#123; System.out.println("执行doSecond()方法"); &#125;&#125;工厂类(cglb可以增强不包含接口的类):12345678910111213141516171819202122232425262728293031323334353637383940package com.learn.factory;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import com.learn.service.SomeService;public class MyCglbFactory implements MethodInterceptor &#123; private SomeService target; public MyCglbFactory() &#123; target = new SomeService(); &#125; public SomeService myCglibCreator() &#123; //创建增强器对象 Enhancer enhancer = new Enhancer(); //指定目标类，即父类 enhancer.setSuperclass(SomeService.class); //设置回调接口对象 enhancer.setCallback(this); return (SomeService) enhancer.create(); &#125; //回调方法 @Override public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable &#123; //调用目标方法 Object result = method.invoke(target, args); if (result != null &amp;&amp; result != "") &#123; result = ((String) result).toUpperCase(); &#125; return result; &#125; &#125;测试类:12345678910111213141516package com.learn.test;import com.learn.factory.MyCglbFactory;import com.learn.service.SomeService;public class MyTest &#123; public static void main(String[] agrs) &#123; SomeService servcie = new MyCglbFactory().myCglibCreator(); String result = servcie.doFirst(); System.out.println(result); servcie.doSecond(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用基本操作]]></title>
    <url>%2FOracle%2Fa08da4e8.html</url>
    <content type="text"><![CDATA[oracle数据库常用基本操作–查看数据库名select name from v$database;–查看数据库实例名select instance_name from v$instance;show parameter instance;–查看当前登录用户默认表空间，临时表空间select username,default_tablespace,temporary_tablespace from user_users;–查看用户和默认表空间的关系select username,default_tablespace from dba_users;–查看当前用户能访问的表select * from user_tables;–Oracle查询用户表select * from user_all_tables;–Oracle查询用户视图select * from user_views;–查询所有函数和储存过程：select * from user_source;–查询所有用户：select * from all_users;select * from dba_users–查看当前用户连接：select * from v$Session;–查看用户角色SELECT * FROM USER_ROLE_PRIVS;–查看当前用户权限：select * from session_privs;–查看所有用户所拥有的角色SELECT * FROM DBA_ROLE_PRIVS;–查看所有角色select * from dba_roles;–查看数据库名SELECT NAME FROM V$DATABASE;–查看所有表空间使用情况12345678910select a.file_id "FileNo", a.tablespace_name "Tablespace_name", a.bytes "Bytes", a.bytes - sum(nvl(b.bytes, 0)) "Used", sum(nvl(b.bytes, 0)) "Free", sum(nvl(b.bytes, 0)) / a.bytes * 100 "%free" from dba_data_files a, dba_free_space b where a.file_id = b.file_id(+) group by a.tablespace_name, a.file_id, a.bytes order by a.tablespace_name;创建表空间在plsql工具中执行以下语句，可建立Oracle表空间。分为四步：第1步：创建临时表空间123456create temporary tablespace test_temp tempfile 'F:\DataBase\test\test_temp.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;第2步：创建数据表空间1234567891011121314create tablespace test_data logging datafile 'F:\DataBase\test\test_data.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;``` ### 第3步：创建用户并指定表空间```SQLcreate user test identified by 123 default tablespace test_data temporary tablespace test_temp;第4步：给用户授予权限1grant connect,resource to test;注:oracle12c 创建用户时必须以c##开头，否则报错如果删除用户使用drop即可，如果要删除表空间的同时，删除对应的文件可以这样123drop user username cascade ;drop tablespace caifenglin_data including contents and datafiles cascade constraints ;drop tablespace caifenglin_temp including contents and datafiles cascade constraints ;导入导出命令123expdp system/ directory=EXPDIR dumpfile=river_base_20161108.dmp SCHEMAS=c##GD_RIVER_UAT,c##GD_PROCESS_UATimp system/yjs123 file='C:\Users\admin\Desktop\20130401\Bao\backup\2013-04-01_morning.dmp' tablespaces=test_data full=y ignore=yOracle_创建用户_授予权限123456789101112--创建用户,需要足够的权限 createcreate user hzf identified by hzf; --给用户bjsxt分配权限 grantgrant connect,resource to hzf;grant dba to hzf;--撤销权限 revokerevoke connect,resource from hzf; --删除用户drop user hzf;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle实例名和服务名以及数据库名区别]]></title>
    <url>%2FOracle%2F1b25f37f.html</url>
    <content type="text"><![CDATA[一、数据库名什么是数据库名？数据库名就是一个数据库的标识，就像人的身份证号一样。他用参数DB_NAME表示，如果一台机器上装了多全数据库，那么每一个数据库都有一个数据库名。在数据库安装或创建完成之后，参数DB_NAME被写入参数文件之中。格式如下：DB_NAME=myorcl…在创建数据库时就应考虑好数据库名，并且在创建完数据库之后，数据库名不宜修改，即使要修改也会很麻烦。因为，数据库名还被写入控制文件中，控制文件是以二 进制形式存储的，用户无法修改控制文件的内容。假设用户修改了参数文件中的数据库名，即修改DB_NAME的值。但是在Oracle启动时，由于参数文件 中的DB_NAME与控制文件中的数据库名不一致，导致数据库启动失败，将返回ORA-01103错误。DB_NAME和instance_name在\oracle\admin\szcg\pfile\下的init.ora文件中，其中szcg是数据库名数据库名的作用数据库名是在安装数据库、创建新的数据库、创建数据库控制文件、修改数据结构、备份与恢复数据库时都需要使用到的。有很多Oracle安装文件目录是与数据库名相关的，如：winnt: d:\oracle\product\10.1.0\oradata\DB_NAME...Unix: /home/app/oracle/product/10.1.0/oradata/DB_NAME/…pfile:winnt: d:\oracle\product\10.1.0\admin\DB_NAME\pfile\ini.oraUnix: /home/app/oracle/product/10.1.0/admin/DB_NAME/pfile/init$ORACLE_SID.ora跟踪文件目录：winnt: /home/app/oracle/product/10.1.0/admin/DB_NAME/bdump/…另外，在创建数据时，careate database命令中的数据库名也要与参数文件中DB_NAME参数的值一致，否则将产生错误。同样，修改数据库结构的语句alter database，当然也要指出要修改的数据库的名称。如果控制文件损坏或丢失，数据库将不能加载，这时要重新创建控制文件，方法是以nomount方式启动实例，然后以create controlfile命令创建控制文件，当然这个命令中也是指指DB_NAME。还有在备份或恢复数据库时，都需要用到数据库名。总之，数据库名很重要，要准确理解它的作用查询当前数据名方法一:select name from v$database;方法二：show parameter db方法三：查看参数文件。select global_name from global_name;修改数据库名前面建议：应在创建数据库时就确定好数据库名，数据库名不应作修改，因为修改数据库名是一件比较复杂的事情。那么现在就来说明一下，如何在已创建数据之后，修改数据库名。步骤如下：1.关闭数据库。2.修改数据库参数文件中的DB_NAME参数的值为新的数据库名。3.以NOMOUNT方式启动实例，修建控制文件(有关创建控制文件的命令语法，请参考oracle文档)二、数据库实例名什么是数据库实例名？数据库实例名是用于和操作系统进行联系的标识，就是说数据库和操作系统之间的交互用的是数据库实例名。实例名也被写入参数文件中，该参数为instance_name，在winnt平台中，实例名同时也被写入注册表。数据库名和实例名可以相同也可以不同。在一般情况下，数据库名和实例名是一对一的关系，但如果在oracle并行服务器架构(即oracle实时应用集群)中，数据库名和实例名是一对多的关系。这一点在第一篇中已有图例说明。查询当前数据库实例名方法一：select instance_name from v$instance;方法二：show parameter instance方法三：在参数文件中查询。Unix下可以这样看：$ ps -ef|grep ora_进程的最后几个字母就是sid在oracle的安装目录下,如D:/oracle/product/10.2.0/db_1/dbs,看文件名如SPFILEORCL.ORA,那么就是orcl,也就是说文件名字是 “SPFILE**.ORA “,那种的 “**** “就是SID D:/oracle/product/10.2.0/oradata/SID文件夹… 或D:/oracle/product/10.2.0/db_1/dbs/SPFILESID名称.ORA数据库实例名与ORACLE_SID虽然两者都表是oracle实例，但两者是有区别的。instance_name是oracle数据库参数。而ORACLE_SID是操作系统的环境变量。 ORACLD_SID用于与操作系统交互，也就是说，从操作系统的角度访问实例名，必须通过ORACLE_SID。在winnt不 台，ORACLE_SID还需存在于注册表中。且ORACLE_SID必须与instance_name的值一致，否则，你将会收到一个错误，在unix平台，是“ORACLE not available”,在winnt平台，是“TNS:协议适配器错误”。数据库实例名与网络连接数据库实例名除了与操作系统交互外，还用于网络连接的oracle服务器标识。当你配置oracle主机连接串的时候，就需要指定实例名。当然8i以后版本的网络组件要求使用的是服务名SERVICE_NAME。这个概念接下来说明。三、数据库域名什么是数据库域名？在分布式数据库系统中，不同版本的数据库服务器之间，不论运行的操作系统是unix或是windows，各服务器之间都可以通过数据库链路进行远程复制，数据库域名主要用于oracle分布式环境中的复制。举例说明如：全国交通运政系统的分布式数据库，其中：福建节点： fj.jtyz福建厦门节点： xm.fj.jtyz江西： jx.jtyz江西上饶：sr.jx.jtyz这就是数据库域名。数据库域名在存在于参数文件中，他的参数是db_domain.查询数据库域名方法一：select * from v$parameter where name = ‘db_domain’;方法二：show parameter domain方法三：在参数文件中查询。全局数据库名全局数据库名=数据库名+数据库域名，如前述福建节点的全局数据库名是：oradb.fj.jtyz四、数据库服务名什么是数据库服务名？从oracle9i版本开始，引入了一个新的参数，即数据库服务名。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。查询数据库服务名方法一：show parameter service_name方法二：在参数文件中查询（查数据库名）。数据库服务名与网络连接从oracle8i开始的oracle网络组件，数据库与客户端的连接主机串使用数据库服务名。之前用的是ORACLE_SID,即数据库实例名。说一点，服务端默认的端口号一般是389，客户端默认的端口号一般都是1521]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro简介]]></title>
    <url>%2F%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6%2FShiro%2Fd11f3a02.html</url>
    <content type="text"><![CDATA[Shiro简介Apache Shiro是Java的一个安全(权限)框架。Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以完成：认证、授权、加密、会话管理、与Web集成、缓存等。下载: http://shiro.apache.org/功能介绍基本功能点如下图所示：功能简介Authentication：身份认证/登录，验证用户是不是拥有相应的身份；Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；Web Support：Web支持，可以非常容易的集成到Web环境；Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；Testing：提供测试支持；Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。Shiro架构(shiro外部来看)从外部来看Shiro，即从应用程序角度来观察如何使用Shiro完成工作：可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。也就是说对于我们而言，最简单的一个Shiro应用：1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。Shiro内部架构接下来我们来从Shiro内部来看下Shiro的架构，如下图所示：Subject：主体，可以看到主体可以是任何可以与应用交互的“用户”；SecurityManager：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；Realm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；SessionManager：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；SessionDAO：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。到此Shiro架构及其组件就认识完了，接下来挨着学习Shiro的组件吧。]]></content>
      <categories>
        <category>权限框架</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
</search>
